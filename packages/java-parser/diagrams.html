
<!-- This is a generated file -->
<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body {
    background-color: hsl(30, 20%, 95%)
  }
</style>


<link rel='stylesheet' href='https://unpkg.com/chevrotain@4.1.1/diagrams/diagrams.css'>

<script src='https://unpkg.com/chevrotain@4.1.1/diagrams/vendor/railroad-diagrams.js'></script>
<script src='https://unpkg.com/chevrotain@4.1.1/diagrams/src/diagrams_builder.js'></script>
<script src='https://unpkg.com/chevrotain@4.1.1/diagrams/src/diagrams_behavior.js'></script>
<script src='https://unpkg.com/chevrotain@4.1.1/diagrams/src/main.js'></script>

<div id="diagrams" align="center"></div>    

<script>
    window.serializedGrammar = [
  {
    "type": "Rule",
    "name": "typeIdentifier",
    "orgText": "() => {\r\n      // TODO: implement: Identifier but not var in the lexer\r\n      $.CONSUME(t.Identifier);\r\n    }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "literal",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.integerLiteral) },\r\n      { ALT: () => $.SUBRULE($.floatingPointLiteral) },\r\n      { ALT: () => $.SUBRULE($.booleanLiteral) },\r\n      { ALT: () => $.CONSUME(t.CharLiteral) },\r\n      { ALT: () => $.CONSUME(t.StringLiteral) },\r\n      { ALT: () => $.CONSUME(t.Null) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "integerLiteral",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "floatingPointLiteral",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "booleanLiteral",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "CharLiteral",
                "label": "'CharLiteral'",
                "idx": 0,
                "pattern": "'(?:[^\\\\']|\\\\(?:(?:[btnfr\"'\\\\\\/]|[0-7]|[0-7]{2}|[0-3][0-7]{2})|u[0-9a-fA-F]{4}))'"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "StringLiteral",
                "label": "'StringLiteral'",
                "idx": 0,
                "pattern": "\"[^\"\\\\]*(\\\\.[^\"\\\\]*)*\""
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Null",
                "label": "'null'",
                "idx": 0,
                "pattern": "null"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "integerLiteral",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.CONSUME(t.DecimalLiteral) },\r\n      { ALT: () => $.CONSUME(t.HexLiteral) },\r\n      { ALT: () => $.CONSUME(t.OctalLiteral) },\r\n      { ALT: () => $.CONSUME(t.BinaryLiteral) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "DecimalLiteral",
                "label": "'DecimalLiteral'",
                "idx": 0,
                "pattern": "-?(0|[1-9](([0-9]([0-9_]*[0-9])?)?|_+[0-9]([0-9_]*[0-9])?))[lL]?"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "HexLiteral",
                "label": "'HexLiteral'",
                "idx": 0,
                "pattern": "0[xX][0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?[lL]?"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "OctalLiteral",
                "label": "'OctalLiteral'",
                "idx": 0,
                "pattern": "0_*[0-7]([0-7_]*[0-7])?[lL]?"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "BinaryLiteral",
                "label": "'BinaryLiteral'",
                "idx": 0,
                "pattern": "0[bB][01]([01_]*[01])?[lL]?"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "floatingPointLiteral",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.CONSUME(t.FloatLiteral) },\r\n      { ALT: () => $.CONSUME(t.HexFloatLiteral) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "FloatLiteral",
                "label": "'FloatLiteral'",
                "idx": 0,
                "pattern": "-?([0-9]([0-9_]*[0-9])?\\.([0-9]([0-9_]*[0-9])?)?|\\.[0-9]([0-9_]*[0-9])?)([eE][+-]?[0-9]([0-9_]*[0-9])?)?[fFdD]?|[0-9]([0-9_]*[0-9])?([eE][+-]?[0-9]([0-9_]*[0-9])?[fFdD]?|[fFdD])"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "HexFloatLiteral",
                "label": "'HexFloatLiteral'",
                "idx": 0,
                "pattern": "0[xX]([0-9a-fA-F](([0-9a-fA-F]|'_')*[0-9a-fA-F])?\\.?|([0-9a-fA-F](([0-9a-fA-F]|'_')*[0-9a-fA-F])?)?\\.[0-9a-fA-F](([0-9a-fA-F]|'_')*[0-9a-fA-F])?)[pP][+-]?[0-9]([0-9_]*[0-9])?[fFdD]?"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "booleanLiteral",
    "orgText": "() => {\r\n    $.OR([{ ALT: () => $.CONSUME(t.True) }, { ALT: () => $.CONSUME(t.False) }]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "True",
                "label": "'true'",
                "idx": 0,
                "pattern": "true"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "False",
                "label": "'false'",
                "idx": 0,
                "pattern": "false"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "primitiveType",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotation);\r\n    });\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.numericType) },\r\n      { ALT: () => $.CONSUME(t.Boolean) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "numericType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Boolean",
                "label": "'boolean'",
                "idx": 0,
                "pattern": "boolean"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "numericType",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.integralType) },\r\n      { ALT: () => $.SUBRULE($.floatingPointType) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "integralType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "floatingPointType",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "integralType",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.CONSUME(t.Byte) },\r\n      { ALT: () => $.CONSUME(t.Short) },\r\n      { ALT: () => $.CONSUME(t.Int) },\r\n      { ALT: () => $.CONSUME(t.Long) },\r\n      { ALT: () => $.CONSUME(t.Char) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Byte",
                "label": "'byte'",
                "idx": 0,
                "pattern": "byte"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Short",
                "label": "'short'",
                "idx": 0,
                "pattern": "short"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Int",
                "label": "'int'",
                "idx": 0,
                "pattern": "int"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Long",
                "label": "'long'",
                "idx": 0,
                "pattern": "long"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Char",
                "label": "'char'",
                "idx": 0,
                "pattern": "char"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "floatingPointType",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.CONSUME(t.Float) },\r\n      { ALT: () => $.CONSUME(t.Double) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Float",
                "label": "'float'",
                "idx": 0,
                "pattern": "float"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Double",
                "label": "'double'",
                "idx": 0,
                "pattern": "double"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "referenceType",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      // Spec Deviation: by extracting the common \"annotation\" prefix\r\n      // we can avoid backtracking and thus improve performance.\r\n      // Note that the annotation prefix is still present inside\r\n      // \"primitiveType\" and \"classOrInterfaceType\"\r\n      $.SUBRULE($.annotation);\r\n    });\r\n    // Spec Deviation: The array type \"dims\" suffix was extracted to this rule\r\n    // to avoid backtracking for performance reasons.\r\n    $.OR([\r\n      {\r\n        ALT: () => {\r\n          $.SUBRULE($.primitiveType);\r\n          $.SUBRULE($.dims);\r\n        }\r\n      },\r\n      {\r\n        // Spec Deviation: \"typeVariable\" alternative is missing because\r\n        //                 it is included in \"classOrInterfaceType\"\r\n        ALT: () => {\r\n          $.SUBRULE($.classOrInterfaceType);\r\n          $.OPTION(() => {\r\n            $.SUBRULE2($.dims);\r\n          });\r\n        }\r\n      }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "primitiveType",
                "idx": 0
              },
              {
                "type": "NonTerminal",
                "name": "dims",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classOrInterfaceType",
                "idx": 0
              },
              {
                "type": "Option",
                "idx": 0,
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "dims",
                    "idx": 2
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classOrInterfaceType",
    "orgText": "() => {\r\n    // Spec Deviation: The spec says: \"classType | interfaceType\" but \"interfaceType\"\r\n    //                 is not mentioned in the parser because it is identical to \"classType\"\r\n    //                 The distinction is **semantic** not syntactic.\r\n    $.SUBRULE($.classType);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "classType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classType",
    "orgText": "() => {\r\n    // Spec Deviation: Refactored left recursion and alternation to iterations\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotation);\r\n    });\r\n    $.CONSUME(t.Identifier);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeArguments);\r\n    });\r\n    $.MANY2(() => {\r\n      $.CONSUME(t.Dot);\r\n      $.MANY3(() => {\r\n        $.SUBRULE2($.annotation);\r\n      });\r\n      // TODO: Semantic Check: This Identifier cannot be \"var\"\r\n      $.CONSUME2(t.Identifier);\r\n      $.OPTION2({\r\n        // To avoid confusion with \"TypeArgumentsOrDiamond\" rule\r\n        // as we use the \"classType\" rule in the \"identifyNewExpressionType\"\r\n        // optimized lookahead rule.\r\n        GATE: () => $.LA(2).tokenType !== t.Greater,\r\n        DEF: () => {\r\n          $.SUBRULE2($.typeArguments);\r\n        }\r\n      });\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Repetition",
            "idx": 3,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 2
              }
            ]
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          },
          {
            "type": "Option",
            "idx": 2,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "typeArguments",
                "idx": 2
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceType",
    "orgText": "() => {\r\n    $.SUBRULE($.classType);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "classType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeVariable",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotation);\r\n    });\r\n    // TODO: Semantic Check: This Identifier cannot be \"var\"\r\n    $.CONSUME(t.Identifier);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "dims",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotation);\r\n    });\r\n    $.CONSUME(t.LSquare);\r\n    $.CONSUME(t.RSquare);\r\n    $.MANY2(() => {\r\n      $.MANY3(() => {\r\n        $.SUBRULE2($.annotation);\r\n      });\r\n      $.CONSUME2(t.LSquare);\r\n      $.CONSUME2(t.RSquare);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "LSquare",
        "label": "'['",
        "idx": 0,
        "pattern": "["
      },
      {
        "type": "Terminal",
        "name": "RSquare",
        "label": "']'",
        "idx": 0,
        "pattern": "]"
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Repetition",
            "idx": 3,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 2
              }
            ]
          },
          {
            "type": "Terminal",
            "name": "LSquare",
            "label": "'['",
            "idx": 2,
            "pattern": "["
          },
          {
            "type": "Terminal",
            "name": "RSquare",
            "label": "']'",
            "idx": 2,
            "pattern": "]"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeParameter",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.typeParameterModifier);\r\n    });\r\n    $.SUBRULE($.typeIdentifier);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeBound);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeParameterModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "typeIdentifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeBound",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeParameterModifier",
    "orgText": "() => {\r\n    $.SUBRULE($.annotation);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "annotation",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeBound",
    "orgText": "() => {\r\n    $.CONSUME(t.Extends);\r\n    // Spec Deviation: The alternative with \"TypeVariable\" is not specified\r\n    //      because it's syntax is included in \"classOrInterfaceType\"\r\n    $.SUBRULE($.classOrInterfaceType);\r\n    $.MANY2(() => {\r\n      $.SUBRULE($.additionalBound);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Extends",
        "label": "'extends'",
        "idx": 0,
        "pattern": "extends"
      },
      {
        "type": "NonTerminal",
        "name": "classOrInterfaceType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "additionalBound",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "additionalBound",
    "orgText": "() => {\r\n    $.CONSUME(t.At);\r\n    $.SUBRULE($.interfaceType);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "At",
        "label": "'@'",
        "idx": 0,
        "pattern": "@"
      },
      {
        "type": "NonTerminal",
        "name": "interfaceType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeArguments",
    "orgText": "() => {\r\n    $.CONSUME(t.Less);\r\n    $.SUBRULE($.typeArgumentList);\r\n    $.CONSUME(t.Greater);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Less",
        "label": "'<'",
        "idx": 0,
        "pattern": "<"
      },
      {
        "type": "NonTerminal",
        "name": "typeArgumentList",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Greater",
        "label": "'>'",
        "idx": 0,
        "pattern": ">"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeArgumentList",
    "orgText": "() => {\r\n    $.SUBRULE($.typeArgument);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.typeArgument);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "typeArgument",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "typeArgument",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeArgument",
    "orgText": "() => {\r\n    // TODO: performance: evaluate flipping the order of alternatives\r\n    $.OR([\r\n      {\r\n        GATE: $.BACKTRACK($.referenceType),\r\n        ALT: () => $.SUBRULE($.referenceType)\r\n      },\r\n      { ALT: () => $.SUBRULE($.wildcard) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "referenceType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "wildcard",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "wildcard",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotation);\r\n    });\r\n    $.CONSUME(t.QuestionMark);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.wildcardBounds);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "QuestionMark",
        "label": "'?'",
        "idx": 0,
        "pattern": "?"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "wildcardBounds",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "wildcardBounds",
    "orgText": "() => {\r\n    // TODO: consider in-lining suffix into the alternatives to match the spec more strongly\r\n    $.OR([\r\n      { ALT: () => $.CONSUME(t.Extends) },\r\n      { ALT: () => $.CONSUME(t.Super) }\r\n    ]);\r\n    $.SUBRULE($.referenceType);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Extends",
                "label": "'extends'",
                "idx": 0,
                "pattern": "extends"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Super",
                "label": "'super'",
                "idx": 0,
                "pattern": "super"
              }
            ]
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "referenceType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "moduleName",
    "orgText": "() => {\r\n    $.CONSUME(t.Identifier);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Dot);\r\n      $.CONSUME2(t.Identifier);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "packageName",
    "orgText": "() => {\r\n    $.CONSUME(t.Identifier);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Dot);\r\n      $.CONSUME2(t.Identifier);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeName",
    "orgText": "() => {\r\n    // Spec Deviation: The last Identifier in a \"typeName\" may not be be \"var\"\r\n    //                 But the parser does not check for that.\r\n    // TODO: post parsing semantic check: last \"Identifier\" in a \"typeName\"\r\n    //                                    cannot be the \"var\" keyword\r\n    // TODO: option 2 implement \"Not Var\" Ident using token categories?\r\n    $.CONSUME(t.Identifier);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Dot);\r\n      $.CONSUME2(t.Identifier);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "expressionName",
    "orgText": "() => {\r\n    // Spec Deviation: in-lined \"ambiguousName\" to be LL(K)\r\n    $.CONSUME(t.Identifier);\r\n    $.MANY({\r\n      // expressionName could be called by \"qualifiedExplicitConstructorInvocation\"\r\n      // in that case it may be followed by \".super\" so we need to look two tokens\r\n      // ahead.\r\n      GATE: () => this.LA(2).tokenType === t.Identifier,\r\n      DEF: () => {\r\n        $.CONSUME(t.Dot);\r\n        $.CONSUME2(t.Identifier);\r\n      }\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodName",
    "orgText": "() => {\r\n    $.CONSUME(t.Identifier);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "packageOrTypeName",
    "orgText": "() => {\r\n    $.CONSUME(t.Identifier);\r\n    $.MANY({\r\n      // In some contexts a \"Dot Star\" (.*) may appear\r\n      // after a \"packageOrTypeName\", by default Chevrotain will\r\n      // only look a single token ahead (Dot) to determine if another iteration\r\n      // exists which will cause a parsing error for inputs such as:\r\n      // \"import a.b.c.*\"\r\n      GATE: () => this.LA(2).tokenType !== t.Star,\r\n      DEF: () => {\r\n        $.CONSUME(t.Dot);\r\n        $.CONSUME2(t.Identifier);\r\n      }\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ambiguousName",
    "orgText": "() => {\r\n    $.CONSUME(t.Identifier);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Dot);\r\n      $.CONSUME2(t.Identifier);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classDeclaration",
    "orgText": "() => {\r\n    // Spec Deviation: extracted common \"{classModifier}\" prefix\r\n    //      extraction is safe because there are no other references to\r\n    //      \"normalClassDeclaration\" and \"enumDeclaration\"\r\n    $.MANY(() => {\r\n      $.SUBRULE($.classModifier);\r\n    });\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.normalClassDeclaration) },\r\n      { ALT: () => $.SUBRULE($.enumDeclaration) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "normalClassDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "enumDeclaration",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "normalClassDeclaration",
    "orgText": "() => {\r\n    // Spec Deviation: extracted common \"{classModifier}\" to \"classDeclaration\"\r\n    $.CONSUME(t.Class);\r\n    $.SUBRULE($.typeIdentifier);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeParameters);\r\n    });\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.superclass);\r\n    });\r\n    $.OPTION3(() => {\r\n      $.SUBRULE($.superinterfaces);\r\n    });\r\n    $.SUBRULE($.classBody);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Class",
        "label": "'class'",
        "idx": 0,
        "pattern": "class"
      },
      {
        "type": "NonTerminal",
        "name": "typeIdentifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeParameters",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "superclass",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "superinterfaces",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "classBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classModifier",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.annotation) },\r\n      { ALT: () => $.CONSUME(t.Public) },\r\n      { ALT: () => $.CONSUME(t.Protected) },\r\n      { ALT: () => $.CONSUME(t.Private) },\r\n      { ALT: () => $.CONSUME(t.Abstract) },\r\n      { ALT: () => $.CONSUME(t.Static) },\r\n      { ALT: () => $.CONSUME(t.Final) },\r\n      { ALT: () => $.CONSUME(t.Strictfp) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Protected",
                "label": "'protected'",
                "idx": 0,
                "pattern": "protected"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Abstract",
                "label": "'abstract'",
                "idx": 0,
                "pattern": "abstract"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Final",
                "label": "'final'",
                "idx": 0,
                "pattern": "final"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Strictfp",
                "label": "'strictfp'",
                "idx": 0,
                "pattern": "strictfp"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeParameters",
    "orgText": "() => {\r\n    $.CONSUME(t.Less);\r\n    $.SUBRULE($.typeParameterList);\r\n    $.CONSUME(t.Greater);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Less",
        "label": "'<'",
        "idx": 0,
        "pattern": "<"
      },
      {
        "type": "NonTerminal",
        "name": "typeParameterList",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Greater",
        "label": "'>'",
        "idx": 0,
        "pattern": ">"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeParameterList",
    "orgText": "() => {\r\n    $.SUBRULE($.typeParameter);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.typeParameter);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "typeParameter",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "typeParameter",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "superclass",
    "orgText": "() => {\r\n    $.CONSUME(t.Extends);\r\n    $.SUBRULE($.classType);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Extends",
        "label": "'extends'",
        "idx": 0,
        "pattern": "extends"
      },
      {
        "type": "NonTerminal",
        "name": "classType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "superinterfaces",
    "orgText": "() => {\r\n    $.CONSUME(t.Implements);\r\n    $.SUBRULE($.interfaceTypeList);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Implements",
        "label": "'implements'",
        "idx": 0,
        "pattern": "implements"
      },
      {
        "type": "NonTerminal",
        "name": "interfaceTypeList",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceTypeList",
    "orgText": "() => {\r\n    $.SUBRULE($.interfaceType);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.interfaceType);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "interfaceType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "interfaceType",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classBody",
    "orgText": "() => {\r\n    $.CONSUME(t.LCurly);\r\n    $.MANY(() => {\r\n      $.SUBRULE($.classBodyDeclaration);\r\n    });\r\n    $.CONSUME(t.RCurly);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classBodyDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classBodyDeclaration",
    "orgText": "() => {\r\n    const nextRuleType = $.BACKTRACK_LOOKAHEAD(\r\n      $.identifyClassBodyDeclarationType\r\n    );\r\n\r\n    $.OR([\r\n      {\r\n        GATE: () =>\r\n          nextRuleType >= classBodyTypes.fieldDeclaration &&\r\n          nextRuleType <= classBodyTypes.semiColon,\r\n        ALT: () => $.SUBRULE($.classMemberDeclaration, { ARGS: [nextRuleType] })\r\n      },\r\n      // no gate needed for the initializers because these are LL(1) rules.\r\n      { ALT: () => $.SUBRULE($.instanceInitializer) },\r\n      { ALT: () => $.SUBRULE($.staticInitializer) },\r\n      {\r\n        GATE: () => nextRuleType === classBodyTypes.constructorDeclaration,\r\n        ALT: () => $.SUBRULE($.constructorDeclaration)\r\n      }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classMemberDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "instanceInitializer",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "staticInitializer",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "constructorDeclaration",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classMemberDeclaration",
    "orgText": "nextRuleType => {\r\n    $.OR([\r\n      {\r\n        GATE: () => nextRuleType === classBodyTypes.fieldDeclaration,\r\n        ALT: () => $.SUBRULE($.fieldDeclaration)\r\n      },\r\n      {\r\n        GATE: () => nextRuleType === classBodyTypes.methodDeclaration,\r\n        ALT: () => $.SUBRULE($.methodDeclaration)\r\n      },\r\n      {\r\n        GATE: () => nextRuleType === classBodyTypes.classDeclaration,\r\n        ALT: () => $.SUBRULE($.classDeclaration)\r\n      },\r\n      {\r\n        GATE: () => nextRuleType === classBodyTypes.interfaceDeclaration,\r\n        ALT: () => $.SUBRULE($.interfaceDeclaration)\r\n      },\r\n      {\r\n        // No GATE is needed as this is LL(1)\r\n        ALT: () => $.CONSUME(t.Semicolon)\r\n      }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "fieldDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "methodDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "interfaceDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Semicolon",
                "label": "';'",
                "idx": 0,
                "pattern": ";"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "fieldDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.fieldModifier);\r\n    });\r\n    $.SUBRULE($.unannType);\r\n    $.SUBRULE($.variableDeclaratorList);\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "fieldModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorList",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "fieldModifier",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.annotation) },\r\n      { ALT: () => $.CONSUME(t.Public) },\r\n      { ALT: () => $.CONSUME(t.Protected) },\r\n      { ALT: () => $.CONSUME(t.Private) },\r\n      { ALT: () => $.CONSUME(t.Static) },\r\n      { ALT: () => $.CONSUME(t.Final) },\r\n      { ALT: () => $.CONSUME(t.Transient) },\r\n      { ALT: () => $.CONSUME(t.Volatile) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Protected",
                "label": "'protected'",
                "idx": 0,
                "pattern": "protected"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Final",
                "label": "'final'",
                "idx": 0,
                "pattern": "final"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Transient",
                "label": "'transient'",
                "idx": 0,
                "pattern": "transient"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Volatile",
                "label": "'volatile'",
                "idx": 0,
                "pattern": "volatile"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableDeclaratorList",
    "orgText": "() => {\r\n    $.SUBRULE($.variableDeclarator);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.variableDeclarator);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "variableDeclarator",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "variableDeclarator",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableDeclarator",
    "orgText": "() => {\r\n    $.SUBRULE($.variableDeclaratorId);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.Equals);\r\n      $.SUBRULE($.variableInitializer);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Equals",
            "label": "'='",
            "idx": 0,
            "pattern": "="
          },
          {
            "type": "NonTerminal",
            "name": "variableInitializer",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableDeclaratorId",
    "orgText": "() => {\r\n    $.CONSUME(t.Identifier);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.dims);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dims",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableInitializer",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.expression) },\r\n      { ALT: () => $.SUBRULE($.arrayInitializer) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "expression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "arrayInitializer",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannType",
    "orgText": "() => {\r\n    $.OR([\r\n      // The \"unannReferenceType\" must appear before the \"unannPrimitiveType\" type\r\n      // due to common prefix\r\n      { ALT: () => $.SUBRULE($.unannReferenceType) },\r\n      { ALT: () => $.SUBRULE($.unannPrimitiveType) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannReferenceType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannPrimitiveType",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannPrimitiveType",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.numericType) },\r\n      { ALT: () => $.CONSUME(t.Boolean) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "numericType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Boolean",
                "label": "'boolean'",
                "idx": 0,
                "pattern": "boolean"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannReferenceType",
    "orgText": "() => {\r\n    $.OR([\r\n      // \"unannArrayType\" must appear before \"unannClassOrInterfaceType\"\r\n      // due to common prefix.\r\n      // TODO: performance: evaluate getting rid of backtracking\r\n      {\r\n        GATE: $.BACKTRACK($.unannArrayType),\r\n        ALT: () => $.SUBRULE($.unannArrayType)\r\n      },\r\n      { ALT: () => $.SUBRULE($.unannClassOrInterfaceType) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannArrayType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannClassOrInterfaceType",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannClassOrInterfaceType",
    "orgText": "() => {\r\n    // Spec Deviation: The spec says: \"UnannClassType  | UnannInterfaceType\" but \"UnannInterfaceType\"\r\n    //                 is not mentioned in the parser because it is identical to \"UnannClassType\"\r\n    //                 The distinction is **semantic** not syntactic.\r\n    $.SUBRULE($.unannClassType);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "unannClassType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannClassType",
    "orgText": "() => {\r\n    // Spec Deviation: Refactored left recursion and alternation to iterations\r\n    $.CONSUME(t.Identifier);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeArguments);\r\n    });\r\n    $.MANY2(() => {\r\n      $.CONSUME(t.Dot);\r\n      $.MANY3(() => {\r\n        $.SUBRULE2($.annotation);\r\n      });\r\n      // TODO: Semantic Check: This Identifier cannot be \"var\"\r\n      $.CONSUME2(t.Identifier);\r\n      $.OPTION2(() => {\r\n        $.SUBRULE2($.typeArguments);\r\n      });\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Repetition",
            "idx": 3,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 2
              }
            ]
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          },
          {
            "type": "Option",
            "idx": 2,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "typeArguments",
                "idx": 2
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannInterfaceType",
    "orgText": "() => {\r\n    $.SUBRULE($.unannClassType);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "unannClassType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannTypeVariable",
    "orgText": "() => {\r\n    // TODO: Semantic Check: This Identifier cannot be \"var\"\r\n    // TODO: or define as token type?\r\n    $.CONSUME(t.Identifier);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannArrayType",
    "orgText": "() => {\r\n    // Spec Deviation: The alternative with \"unannTypeVariable\" is not specified\r\n    //      because it's syntax is included in \"unannClassOrInterfaceType\"\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.unannPrimitiveType) },\r\n      { ALT: () => $.SUBRULE($.unannClassOrInterfaceType) }\r\n    ]);\r\n    $.SUBRULE($.dims);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannPrimitiveType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannClassOrInterfaceType",
                "idx": 0
              }
            ]
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "dims",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.methodModifier);\r\n    });\r\n    $.SUBRULE($.methodHeader);\r\n    $.SUBRULE($.methodBody);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "methodModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "methodHeader",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "methodBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodModifier",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.annotation) },\r\n      { ALT: () => $.CONSUME(t.Public) },\r\n      { ALT: () => $.CONSUME(t.Protected) },\r\n      { ALT: () => $.CONSUME(t.Private) },\r\n      { ALT: () => $.CONSUME(t.Abstract) },\r\n      { ALT: () => $.CONSUME(t.Static) },\r\n      { ALT: () => $.CONSUME(t.Final) },\r\n      { ALT: () => $.CONSUME(t.Synchronized) },\r\n      { ALT: () => $.CONSUME(t.Native) },\r\n      { ALT: () => $.CONSUME(t.Strictfp) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Protected",
                "label": "'protected'",
                "idx": 0,
                "pattern": "protected"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Abstract",
                "label": "'abstract'",
                "idx": 0,
                "pattern": "abstract"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Final",
                "label": "'final'",
                "idx": 0,
                "pattern": "final"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Synchronized",
                "label": "'synchronized'",
                "idx": 0,
                "pattern": "synchronized"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Native",
                "label": "'native'",
                "idx": 0,
                "pattern": "native"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Strictfp",
                "label": "'strictfp'",
                "idx": 0,
                "pattern": "strictfp"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodHeader",
    "orgText": "() => {\r\n    // Spec Deviation: extracted common prefix from both alternatives\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeParameters);\r\n      $.MANY(() => {\r\n        $.SUBRULE($.annotation);\r\n      });\r\n    });\r\n    $.SUBRULE($.result);\r\n    $.SUBRULE($.methodDeclarator);\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.throws);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeParameters",
            "idx": 0
          },
          {
            "type": "Repetition",
            "idx": 0,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "result",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "methodDeclarator",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "throws",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "result",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.unannType) },\r\n      { ALT: () => $.CONSUME(t.Void) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Void",
                "label": "'void'",
                "idx": 0,
                "pattern": "void"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodDeclarator",
    "orgText": "() => {\r\n    $.CONSUME(t.Identifier);\r\n    $.CONSUME(t.LBrace);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.formalParameterList);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.dims);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "formalParameterList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dims",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "receiverParameter",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotation);\r\n    });\r\n    $.SUBRULE($.unannType);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.Identifier);\r\n      $.CONSUME(t.Dot);\r\n    });\r\n    $.CONSUME(t.This);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 0,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          },
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "This",
        "label": "'this'",
        "idx": 0,
        "pattern": "this"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "formalParameterList",
    "orgText": "() => {\r\n    $.SUBRULE($.formalParameter);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.formalParameter);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "formalParameter",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "formalParameter",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "formalParameter",
    "orgText": "() => {\r\n    $.OR([\r\n      // Spec Deviation: extracted to \"variableParaRegularParameter\"\r\n      {\r\n        GATE: $.BACKTRACK($.variableParaRegularParameter),\r\n        ALT: () => $.SUBRULE($.variableParaRegularParameter)\r\n      },\r\n      { ALT: () => $.SUBRULE($.variableArityParameter) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "variableParaRegularParameter",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "variableArityParameter",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableParaRegularParameter",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.variableModifier);\r\n    });\r\n    $.SUBRULE($.unannType);\r\n    $.SUBRULE($.variableDeclaratorId);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableArityParameter",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.variableModifier);\r\n    });\r\n    $.SUBRULE($.unannType);\r\n    $.MANY2(() => {\r\n      $.SUBRULE($.annotation);\r\n    });\r\n    $.CONSUME(t.DotDotDot);\r\n    $.CONSUME(t.Identifier);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "DotDotDot",
        "label": "'...'",
        "idx": 0,
        "pattern": "..."
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableModifier",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.annotation) },\r\n      { ALT: () => $.CONSUME(t.Final) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Final",
                "label": "'final'",
                "idx": 0,
                "pattern": "final"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "throws",
    "orgText": "() => {\r\n    $.CONSUME(t.Throws);\r\n    $.SUBRULE($.exceptionTypeList);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Throws",
        "label": "'throws'",
        "idx": 0,
        "pattern": "throws"
      },
      {
        "type": "NonTerminal",
        "name": "exceptionTypeList",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "exceptionTypeList",
    "orgText": "() => {\r\n    $.SUBRULE($.exceptionType);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.exceptionType);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "exceptionType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "exceptionType",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "exceptionType",
    "orgText": "() => {\r\n    // Spec Deviation: \"typeVariable\" alternative is missing because\r\n    //                 it is contained in classType.\r\n    $.SUBRULE($.classType);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "classType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodBody",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.block) },\r\n      { ALT: () => $.CONSUME(t.Semicolon) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "block",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Semicolon",
                "label": "';'",
                "idx": 0,
                "pattern": ";"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "instanceInitializer",
    "orgText": "() => {\r\n    $.SUBRULE($.block);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "staticInitializer",
    "orgText": "() => {\r\n    $.CONSUME(t.Static);\r\n    $.SUBRULE($.block);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Static",
        "label": "'static'",
        "idx": 0,
        "pattern": "static"
      },
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constructorDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.constructorModifier);\r\n    });\r\n    $.SUBRULE($.constructorDeclarator);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.throws);\r\n    });\r\n    $.SUBRULE($.constructorBody);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "constructorModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "constructorDeclarator",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "throws",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "constructorBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constructorModifier",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.annotation) },\r\n      { ALT: () => $.CONSUME(t.Public) },\r\n      { ALT: () => $.CONSUME(t.Protected) },\r\n      { ALT: () => $.CONSUME(t.Private) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Protected",
                "label": "'protected'",
                "idx": 0,
                "pattern": "protected"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constructorDeclarator",
    "orgText": "() => {\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeParameters);\r\n    });\r\n    $.SUBRULE($.simpleTypeName);\r\n    $.CONSUME(t.LBrace);\r\n    $.OPTION2({\r\n      // a \"formalParameterList\" and a \"receiverParameter\"\r\n      // cannot be distinguished using fixed lookahead.\r\n      GATE: $.BACKTRACK($.receiverParameter),\r\n      DEF: () => {\r\n        $.SUBRULE($.receiverParameter);\r\n        $.CONSUME(t.Comma);\r\n      }\r\n    });\r\n    $.OPTION3(() => {\r\n      $.SUBRULE($.formalParameterList);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeParameters",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "simpleTypeName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "receiverParameter",
            "idx": 0
          },
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          }
        ]
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "formalParameterList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "simpleTypeName",
    "orgText": "() => {\r\n    // TODO: implement: Identifier but not var\r\n    $.CONSUME(t.Identifier);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constructorBody",
    "orgText": "() => {\r\n    $.CONSUME(t.LCurly);\r\n    $.OPTION({\r\n      GATE: $.BACKTRACK($.explicitConstructorInvocation),\r\n      DEF: () => {\r\n        $.SUBRULE($.explicitConstructorInvocation);\r\n      }\r\n    });\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.blockStatements);\r\n    });\r\n    $.CONSUME(t.RCurly);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "explicitConstructorInvocation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "blockStatements",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "explicitConstructorInvocation",
    "orgText": "() => {\r\n    // Spec Deviation: split into two separate sub rules.\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.unqualifiedExplicitConstructorInvocation) },\r\n      { ALT: () => $.SUBRULE($.qualifiedExplicitConstructorInvocation) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unqualifiedExplicitConstructorInvocation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "qualifiedExplicitConstructorInvocation",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unqualifiedExplicitConstructorInvocation",
    "orgText": "() => {\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeArguments);\r\n    });\r\n    $.OR([\r\n      {\r\n        ALT: () => $.CONSUME(t.This)\r\n      },\r\n      {\r\n        ALT: () => $.CONSUME(t.Super)\r\n      }\r\n    ]);\r\n    $.CONSUME(t.LBrace);\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.argumentList);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "This",
                "label": "'this'",
                "idx": 0,
                "pattern": "this"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Super",
                "label": "'super'",
                "idx": 0,
                "pattern": "super"
              }
            ]
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "argumentList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "qualifiedExplicitConstructorInvocation",
    "orgText": "() => {\r\n    // Spec Deviation: According to the spec the prefix may be a \"primary' as well,\r\n    //                 however, most primary variants don't make sense here\r\n    // TODO: discover which primary forms could be valid here\r\n    //       and handle only those specific cases.\r\n    //       It is best if we avoid referencing \"primary\" rule from\r\n    //       outside the expressions rules as the expressions rules are not aligned\r\n    //       to the spec style, so we want the smallest possible \"external api\"\r\n    //       for the expressions rules.\r\n    $.SUBRULE($.expressionName);\r\n    $.CONSUME(t.Dot);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeArguments);\r\n    });\r\n    $.CONSUME(t.Super);\r\n    $.CONSUME(t.LBrace);\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.argumentList);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "expressionName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Dot",
        "label": "'.'",
        "idx": 0,
        "pattern": "."
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Super",
        "label": "'super'",
        "idx": 0,
        "pattern": "super"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "argumentList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.classModifier);\r\n    });\r\n    $.CONSUME(t.Enum);\r\n    $.SUBRULE($.typeIdentifier);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.superinterfaces);\r\n    });\r\n    $.SUBRULE($.enumBody);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Enum",
        "label": "'enum'",
        "idx": 0,
        "pattern": "enum"
      },
      {
        "type": "NonTerminal",
        "name": "typeIdentifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "superinterfaces",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "enumBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumBody",
    "orgText": "() => {\r\n    $.CONSUME(t.LCurly);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.enumConstantList);\r\n    });\r\n    $.OPTION2(() => {\r\n      $.CONSUME(t.Comma);\r\n    });\r\n    $.OPTION3(() => {\r\n      $.SUBRULE($.enumBodyDeclarations);\r\n    });\r\n    $.CONSUME(t.RCurly);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "enumConstantList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          }
        ]
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "enumBodyDeclarations",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumConstantList",
    "orgText": "() => {\r\n    $.SUBRULE($.enumConstant);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.enumConstant);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "enumConstant",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "enumConstant",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumConstant",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.enumConstantModifier);\r\n    });\r\n    $.CONSUME(t.Identifier);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.LBrace);\r\n      $.SUBRULE($.argumentList);\r\n      $.CONSUME(t.RBrace);\r\n    });\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.classBody);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "enumConstantModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "LBrace",
            "label": "'('",
            "idx": 0,
            "pattern": "("
          },
          {
            "type": "NonTerminal",
            "name": "argumentList",
            "idx": 0
          },
          {
            "type": "Terminal",
            "name": "RBrace",
            "label": "')'",
            "idx": 0,
            "pattern": ")"
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classBody",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumConstantModifier",
    "orgText": "() => {\r\n    $.SUBRULE($.annotation);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "annotation",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumBodyDeclarations",
    "orgText": "() => {\r\n    $.CONSUME(t.Semicolon);\r\n    $.MANY(() => {\r\n      $.SUBRULE($.classBodyDeclaration);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classBodyDeclaration",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isClassDeclaration",
    "orgText": "() => {\r\n    if (\r\n      $.OPTION(() => {\r\n        $.CONSUME(t.Semicolon);\r\n      })\r\n    ) {\r\n      // an empty \"TypeDeclaration\"\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      // The {classModifier} is a super grammar of the \"interfaceModifier\"\r\n      // So we must parse all the \"{classModifier}\" before we can distinguish\r\n      // between the alternatives.\r\n      $.MANY(() => {\r\n        $.SUBRULE($.classModifier);\r\n      });\r\n    } catch (e) {\r\n      if (isRecognitionException(e)) {\r\n        // TODO: add original syntax error?\r\n        throw \"Cannot Identify if the <TypeDeclaration> is a <ClassDeclaration> or an <InterfaceDeclaration>\";\r\n      } else {\r\n        throw e;\r\n      }\r\n    }\r\n\r\n    const nextTokenType = this.LA(1).tokenType;\r\n    return nextTokenType === t.Class || nextTokenType === t.Enum;\r\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Semicolon",
            "label": "';'",
            "idx": 0,
            "pattern": ";"
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classModifier",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "identifyClassBodyDeclarationType",
    "orgText": "() => {\r\n    try {\r\n      let nextTokenType = this.LA(1).tokenType;\r\n      let nextNextTokenType = this.LA(2).tokenType;\r\n\r\n      switch (nextTokenType) {\r\n        case t.Semicolon:\r\n          return classBodyTypes.semiColon;\r\n        case t.LCurly:\r\n          return classBodyTypes.instanceInitializer;\r\n        case t.Static:\r\n          switch (nextNextTokenType) {\r\n            case t.LCurly:\r\n              return classBodyTypes.staticInitializer;\r\n          }\r\n      }\r\n\r\n      // We have to look beyond the modifiers to distinguish between the declaration types.\r\n      $.MANY(() => {\r\n        // This alternation includes all possible modifiers for all types of \"ClassBodyDeclaration\"\r\n        // Certain combinations are syntactically invalid, this is **not** checked here,\r\n        // Invalid combinations will cause a descriptive parsing error message to be\r\n        // Created inside the relevant parsing rules **after** this lookahead\r\n        // analysis.\r\n        $.OR([\r\n          { ALT: () => $.SUBRULE($.annotation) },\r\n          { ALT: () => $.CONSUME(t.Public) },\r\n          { ALT: () => $.CONSUME(t.Protected) },\r\n          { ALT: () => $.CONSUME(t.Private) },\r\n          { ALT: () => $.CONSUME(t.Abstract) },\r\n          { ALT: () => $.CONSUME(t.Static) },\r\n          { ALT: () => $.CONSUME(t.Final) },\r\n          { ALT: () => $.CONSUME(t.Transient) },\r\n          { ALT: () => $.CONSUME(t.Volatile) },\r\n          { ALT: () => $.CONSUME(t.Synchronized) },\r\n          { ALT: () => $.CONSUME(t.Native) },\r\n          { ALT: () => $.CONSUME(t.Strictfp) }\r\n        ]);\r\n      });\r\n\r\n      nextTokenType = this.LA(1).tokenType;\r\n      nextNextTokenType = this.LA(2).tokenType;\r\n      if (nextTokenType === t.Identifier && nextNextTokenType === t.LBrace) {\r\n        return classBodyTypes.constructorDeclaration;\r\n      }\r\n\r\n      if (nextTokenType === t.Class || nextTokenType === t.Enum) {\r\n        return classBodyTypes.classDeclaration;\r\n      }\r\n\r\n      if (nextTokenType === t.Interface || nextTokenType === t.At) {\r\n        return classBodyTypes.interfaceDeclaration;\r\n      }\r\n\r\n      if (nextTokenType === t.Void) {\r\n        // method with result type \"void\"\r\n        return classBodyTypes.methodDeclaration;\r\n      }\r\n\r\n      // Type Arguments common prefix\r\n      if (nextTokenType === t.Less) {\r\n        this.SUBRULE($.typeParameters);\r\n        const nextTokenType = this.LA(1).tokenType;\r\n        const nextNextTokenType = this.LA(2).tokenType;\r\n        // \"<T> foo(\" -> constructor\r\n        if (nextTokenType === t.Identifier && nextNextTokenType === t.LBrace) {\r\n          return classBodyTypes.constructorDeclaration;\r\n        }\r\n        // typeParameters can only appear in method or constructor\r\n        // declarations, so if it is not a constructor it must be a method\r\n        return classBodyTypes.methodDeclaration;\r\n      }\r\n\r\n      // Only field or method declarations may be valid at this point.\r\n      // All other alternatives should have been attempted.\r\n      // **both** start with \"unannType\"\r\n      this.SUBRULE($.unannType);\r\n\r\n      const nextToken = this.LA(1);\r\n      nextNextTokenType = this.LA(2).tokenType;\r\n      // \"foo(...\" --> look like method start\r\n      if (\r\n        tokenMatcher(nextToken, t.Identifier) &&\r\n        nextNextTokenType === t.LBrace\r\n      ) {\r\n        return classBodyTypes.methodDeclaration;\r\n      }\r\n\r\n      // a valid field\r\n      // TODO: because we use token categories we should use tokenMatcher everywhere.\r\n      if (tokenMatcher(nextToken, t.Identifier)) {\r\n        return classBodyTypes.fieldDeclaration;\r\n      }\r\n\r\n      return classBodyTypes.unknown;\r\n    } catch (e) {\r\n      // TODO: add info from the original error\r\n      throw Error(\"Cannot Identify the type of a <classBodyDeclaration>\");\r\n    }\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "annotation",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Public",
                    "label": "'public'",
                    "idx": 0,
                    "pattern": "public"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Protected",
                    "label": "'protected'",
                    "idx": 0,
                    "pattern": "protected"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Private",
                    "label": "'private'",
                    "idx": 0,
                    "pattern": "private"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Abstract",
                    "label": "'abstract'",
                    "idx": 0,
                    "pattern": "abstract"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Static",
                    "label": "'static'",
                    "idx": 0,
                    "pattern": "static"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Final",
                    "label": "'final'",
                    "idx": 0,
                    "pattern": "final"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Transient",
                    "label": "'transient'",
                    "idx": 0,
                    "pattern": "transient"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Volatile",
                    "label": "'volatile'",
                    "idx": 0,
                    "pattern": "volatile"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Synchronized",
                    "label": "'synchronized'",
                    "idx": 0,
                    "pattern": "synchronized"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Native",
                    "label": "'native'",
                    "idx": 0,
                    "pattern": "native"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Strictfp",
                    "label": "'strictfp'",
                    "idx": 0,
                    "pattern": "strictfp"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "typeParameters",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "compilationUnit",
    "orgText": "() => {\r\n    // custom optimized backtracking lookahead logic\r\n    const isModule = $.BACKTRACK_LOOKAHEAD($.isModuleCompilationUnit);\r\n    $.OR([\r\n      {\r\n        GATE: () => isModule === false,\r\n        ALT: () => $.SUBRULE($.ordinaryCompilationUnit)\r\n      },\r\n      {\r\n        ALT: () => $.SUBRULE($.modularCompilationUnit)\r\n      }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ordinaryCompilationUnit",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "modularCompilationUnit",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ordinaryCompilationUnit",
    "orgText": "() => {\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.packageDeclaration);\r\n    });\r\n    $.MANY(() => {\r\n      $.SUBRULE($.importDeclaration);\r\n    });\r\n    $.MANY2(() => {\r\n      $.SUBRULE($.typeDeclaration);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "packageDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "importDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeDeclaration",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "modularCompilationUnit",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.importDeclaration);\r\n    });\r\n    $.SUBRULE($.moduleDeclaration);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "importDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "moduleDeclaration",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "packageDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.packageModifier);\r\n    });\r\n    $.CONSUME(t.Package);\r\n    $.CONSUME(t.Identifier);\r\n    $.MANY2(() => {\r\n      $.CONSUME(t.Dot);\r\n      $.CONSUME2(t.Identifier);\r\n    });\r\n    $.CONSUME2(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "packageModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Package",
        "label": "'package'",
        "idx": 0,
        "pattern": "package"
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 2,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "packageModifier",
    "orgText": "() => {\r\n    $.SUBRULE($.annotation);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "annotation",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "importDeclaration",
    "orgText": "() => {\r\n    // Spec Deviation: The spec defines four different kinds of import declarations.\r\n    //                 Our grammar however combines those into a single rule due to difficulties\r\n    //                 distinguishing between the alternatives due to unbound common prefix.\r\n    // TODO: A post parsing step is required to align with the official specs.\r\n    //       The Identifier \"var\" is not allowed in all positions and variations of the importDeclaration\r\n    $.CONSUME(t.Import);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.Static);\r\n    });\r\n    $.SUBRULE($.packageOrTypeName);\r\n    $.OPTION2(() => {\r\n      $.CONSUME(t.Dot);\r\n      $.CONSUME(t.Star);\r\n    });\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Import",
        "label": "'import'",
        "idx": 0,
        "pattern": "import"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Static",
            "label": "'static'",
            "idx": 0,
            "pattern": "static"
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "packageOrTypeName",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Star",
            "label": "'*'",
            "idx": 0,
            "pattern": "*"
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeDeclaration",
    "orgText": "() => {\r\n    const isClassDeclaration = this.BACKTRACK_LOOKAHEAD($.isClassDeclaration);\r\n    $.OR([\r\n      {\r\n        GATE: () => isClassDeclaration,\r\n        ALT: () => $.SUBRULE($.classDeclaration)\r\n      },\r\n      { ALT: () => $.SUBRULE($.interfaceDeclaration) },\r\n      { ALT: () => $.CONSUME(t.Semicolon) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "interfaceDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Semicolon",
                "label": "';'",
                "idx": 0,
                "pattern": ";"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "moduleDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotation);\r\n    });\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.Open);\r\n    });\r\n    $.CONSUME(t.Module);\r\n    $.CONSUME(t.Identifier);\r\n    $.MANY2(() => {\r\n      $.CONSUME(t.Dot);\r\n      $.CONSUME2(t.Identifier);\r\n    });\r\n    $.CONSUME(t.LCurly);\r\n    $.MANY3(() => {\r\n      $.SUBRULE($.moduleDirective);\r\n    });\r\n    $.CONSUME(t.RCurly);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Open",
            "label": "'open'",
            "idx": 0,
            "pattern": "open"
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Module",
        "label": "'module'",
        "idx": 0,
        "pattern": "module"
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Repetition",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "moduleDirective",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "moduleDirective",
    "orgText": "() => {\r\n    // Spec Deviation: Each of the alternatives of \"moduleDirective\" was extracted\r\n    //                 to its own nonTerminal, to reduce verbosity.\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.requiresModuleDirective) },\r\n      { ALT: () => $.SUBRULE($.exportsModuleDirective) },\r\n      { ALT: () => $.SUBRULE($.opensModuleDirective) },\r\n      { ALT: () => $.SUBRULE($.usesModuleDirective) },\r\n      { ALT: () => $.SUBRULE($.providesModuleDirective) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "requiresModuleDirective",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "exportsModuleDirective",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "opensModuleDirective",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "usesModuleDirective",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "providesModuleDirective",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "requiresModuleDirective",
    "orgText": "() => {\r\n    // Spec Deviation: extracted from \"moduleDirective\"\r\n    $.CONSUME(t.Requires);\r\n    $.MANY(() => {\r\n      $.SUBRULE($.requiresModifier);\r\n    });\r\n    $.SUBRULE($.moduleName);\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Requires",
        "label": "'requires'",
        "idx": 0,
        "pattern": "requires"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "requiresModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "moduleName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "exportsModuleDirective",
    "orgText": "() => {\r\n    // Spec Deviation: extracted from \"moduleDirective\"\r\n    $.CONSUME(t.Exports);\r\n    $.SUBRULE($.packageName);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.To);\r\n      $.SUBRULE($.moduleName);\r\n      $.MANY(() => {\r\n        $.CONSUME(t.Comma);\r\n        $.SUBRULE2($.moduleName);\r\n      });\r\n    });\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Exports",
        "label": "'exports'",
        "idx": 0,
        "pattern": "exports"
      },
      {
        "type": "NonTerminal",
        "name": "packageName",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "To",
            "label": "'to'",
            "idx": 0,
            "pattern": "to"
          },
          {
            "type": "NonTerminal",
            "name": "moduleName",
            "idx": 0
          },
          {
            "type": "Repetition",
            "idx": 0,
            "definition": [
              {
                "type": "Terminal",
                "name": "Comma",
                "label": "','",
                "idx": 0,
                "pattern": ","
              },
              {
                "type": "NonTerminal",
                "name": "moduleName",
                "idx": 2
              }
            ]
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "opensModuleDirective",
    "orgText": "() => {\r\n    // Spec Deviation: extracted from \"moduleDirective\"\r\n    $.CONSUME(t.Opens);\r\n    $.SUBRULE($.packageName);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.To);\r\n      $.SUBRULE($.moduleName);\r\n      $.MANY(() => {\r\n        $.CONSUME(t.Comma);\r\n        $.SUBRULE2($.moduleName);\r\n      });\r\n    });\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Opens",
        "label": "'opens'",
        "idx": 0,
        "pattern": "opens"
      },
      {
        "type": "NonTerminal",
        "name": "packageName",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "To",
            "label": "'to'",
            "idx": 0,
            "pattern": "to"
          },
          {
            "type": "NonTerminal",
            "name": "moduleName",
            "idx": 0
          },
          {
            "type": "Repetition",
            "idx": 0,
            "definition": [
              {
                "type": "Terminal",
                "name": "Comma",
                "label": "','",
                "idx": 0,
                "pattern": ","
              },
              {
                "type": "NonTerminal",
                "name": "moduleName",
                "idx": 2
              }
            ]
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "usesModuleDirective",
    "orgText": "() => {\r\n    // Spec Deviation: extracted from \"moduleDirective\"\r\n    $.CONSUME(t.Uses);\r\n    $.SUBRULE($.typeName);\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Uses",
        "label": "'uses'",
        "idx": 0,
        "pattern": "uses"
      },
      {
        "type": "NonTerminal",
        "name": "typeName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "providesModuleDirective",
    "orgText": "() => {\r\n    // Spec Deviation: extracted from \"moduleDirective\"\r\n    $.CONSUME(t.Provides);\r\n    $.CONSUME(t.With);\r\n    $.SUBRULE($.typeName);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.typeName);\r\n    });\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Provides",
        "label": "'provides'",
        "idx": 0,
        "pattern": "provides"
      },
      {
        "type": "Terminal",
        "name": "With",
        "label": "'with'",
        "idx": 0,
        "pattern": "with"
      },
      {
        "type": "NonTerminal",
        "name": "typeName",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "typeName",
            "idx": 2
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "requiresModifier",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.CONSUME(t.Transitive) },\r\n      { ALT: () => $.CONSUME(t.Static) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Transitive",
                "label": "'transitive'",
                "idx": 0,
                "pattern": "transitive"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isModuleCompilationUnit",
    "orgText": "() => {\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.packageDeclaration);\r\n      // a Java Module source code may not contain a package declaration.\r\n      return false;\r\n    });\r\n\r\n    try {\r\n      // the \"{importDeclaration}\" is a common prefix\r\n      $.MANY(() => {\r\n        $.SUBRULE2($.importDeclaration);\r\n      });\r\n\r\n      $.MANY2(() => {\r\n        $.SUBRULE($.annotation);\r\n      });\r\n    } catch (e) {\r\n      // This means we had a syntax error in the imports or annotations\r\n      // So we can't keep parsing deep enough to make the decision\r\n      if (isRecognitionException(e)) {\r\n        // TODO: add original syntax error?\r\n        throw \"Cannot Identify if the source code is an OrdinaryCompilationUnit or  ModularCompilationUnit\";\r\n      } else {\r\n        throw e;\r\n      }\r\n    }\r\n    const nextTokenType = this.LA(1).tokenType;\r\n    return nextTokenType === t.Open || nextTokenType === t.Module;\r\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "packageDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "importDeclaration",
            "idx": 2
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceDeclaration",
    "orgText": "() => {\r\n    const type = this.BACKTRACK_LOOKAHEAD($.identifyInterfaceType);\r\n    $.OR([\r\n      {\r\n        GATE: () => type === InterfaceType.normalInterfaceDeclaration,\r\n        ALT: () => $.SUBRULE($.normalInterfaceDeclaration)\r\n      },\r\n      {\r\n        GATE: () => type === InterfaceType.annotationTypeDeclaration,\r\n        ALT: () => $.SUBRULE($.annotationTypeDeclaration)\r\n      }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "normalInterfaceDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotationTypeDeclaration",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "normalInterfaceDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.interfaceModifier);\r\n    });\r\n    $.CONSUME(t.Interface);\r\n    $.SUBRULE($.typeIdentifier);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeParameters);\r\n    });\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.extendsInterfaces);\r\n    });\r\n    $.SUBRULE($.interfaceBody);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "interfaceModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Interface",
        "label": "'interface'",
        "idx": 0,
        "pattern": "interface"
      },
      {
        "type": "NonTerminal",
        "name": "typeIdentifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeParameters",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "extendsInterfaces",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "interfaceBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceModifier",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.annotation) },\r\n      { ALT: () => $.CONSUME(t.Public) },\r\n      { ALT: () => $.CONSUME(t.Protected) },\r\n      { ALT: () => $.CONSUME(t.Private) },\r\n      { ALT: () => $.CONSUME(t.Abstract) },\r\n      { ALT: () => $.CONSUME(t.Static) },\r\n      { ALT: () => $.CONSUME(t.Strictfp) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Protected",
                "label": "'protected'",
                "idx": 0,
                "pattern": "protected"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Abstract",
                "label": "'abstract'",
                "idx": 0,
                "pattern": "abstract"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Strictfp",
                "label": "'strictfp'",
                "idx": 0,
                "pattern": "strictfp"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "extendsInterfaces",
    "orgText": "() => {\r\n    $.CONSUME(t.Extends);\r\n    $.SUBRULE($.interfaceTypeList);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Extends",
        "label": "'extends'",
        "idx": 0,
        "pattern": "extends"
      },
      {
        "type": "NonTerminal",
        "name": "interfaceTypeList",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceBody",
    "orgText": "() => {\r\n    $.CONSUME(t.LCurly);\r\n    $.MANY(() => {\r\n      $.SUBRULE($.interfaceMemberDeclaration);\r\n    });\r\n    $.CONSUME(t.RCurly);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "interfaceMemberDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceMemberDeclaration",
    "orgText": "() => {\r\n    const detectedType = this.BACKTRACK_LOOKAHEAD(\r\n      $.identifyInterfaceBodyDeclarationType\r\n    );\r\n    $.OR([\r\n      {\r\n        GATE: () => detectedType === InterfaceBodyTypes.constantDeclaration,\r\n        ALT: () => $.SUBRULE($.constantDeclaration)\r\n      },\r\n      {\r\n        GATE: () =>\r\n          detectedType === InterfaceBodyTypes.interfaceMethodDeclaration,\r\n        ALT: () => $.SUBRULE($.interfaceMethodDeclaration)\r\n      },\r\n      {\r\n        GATE: () => detectedType === InterfaceBodyTypes.classDeclaration,\r\n        ALT: () => $.SUBRULE($.classDeclaration)\r\n      },\r\n      {\r\n        GATE: () => detectedType === InterfaceBodyTypes.interfaceDeclaration,\r\n        ALT: () => $.SUBRULE($.interfaceDeclaration)\r\n      },\r\n      {\r\n        // No GATE is needed as this is LL(1)\r\n        ALT: () => $.CONSUME(t.Semicolon)\r\n      }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "constantDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "interfaceMethodDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "interfaceDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Semicolon",
                "label": "';'",
                "idx": 0,
                "pattern": ";"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constantDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.constantModifier);\r\n    });\r\n    $.SUBRULE($.unannType);\r\n    $.SUBRULE($.variableDeclaratorList);\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "constantModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorList",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constantModifier",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.annotation) },\r\n      { ALT: () => $.CONSUME(t.Public) },\r\n      { ALT: () => $.CONSUME(t.Static) },\r\n      { ALT: () => $.CONSUME(t.Final) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Final",
                "label": "'final'",
                "idx": 0,
                "pattern": "final"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceMethodDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.interfaceMethodModifier);\r\n    });\r\n    $.SUBRULE($.methodHeader);\r\n    $.SUBRULE($.methodBody);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "interfaceMethodModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "methodHeader",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "methodBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceMethodModifier",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.annotation) },\r\n      { ALT: () => $.CONSUME(t.Public) },\r\n      { ALT: () => $.CONSUME(t.Private) },\r\n      { ALT: () => $.CONSUME(t.Abstract) },\r\n      { ALT: () => $.CONSUME(t.Default) },\r\n      { ALT: () => $.CONSUME(t.Static) },\r\n      { ALT: () => $.CONSUME(t.Strictfp) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Abstract",
                "label": "'abstract'",
                "idx": 0,
                "pattern": "abstract"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Default",
                "label": "'default'",
                "idx": 0,
                "pattern": "default"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Strictfp",
                "label": "'strictfp'",
                "idx": 0,
                "pattern": "strictfp"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotationTypeDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.interfaceModifier);\r\n    });\r\n    $.CONSUME(t.At);\r\n    $.CONSUME(t.Interface);\r\n    $.SUBRULE($.typeIdentifier);\r\n    $.SUBRULE($.annotationTypeBody);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "interfaceModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "At",
        "label": "'@'",
        "idx": 0,
        "pattern": "@"
      },
      {
        "type": "Terminal",
        "name": "Interface",
        "label": "'interface'",
        "idx": 0,
        "pattern": "interface"
      },
      {
        "type": "NonTerminal",
        "name": "typeIdentifier",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "annotationTypeBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotationTypeBody",
    "orgText": "() => {\r\n    $.CONSUME(t.LCurly);\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotationTypeMemberDeclaration);\r\n    });\r\n    $.CONSUME(t.RCurly);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotationTypeMemberDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotationTypeMemberDeclaration",
    "orgText": "() => {\r\n    const detectedType = this.BACKTRACK_LOOKAHEAD(\r\n      $.identifyAnnotationBodyDeclarationType\r\n    );\r\n    $.OR([\r\n      {\r\n        GATE: () =>\r\n          detectedType === AnnotationBodyTypes.annotationTypeElementDeclaration,\r\n        ALT: () => $.SUBRULE($.annotationTypeElementDeclaration)\r\n      },\r\n      {\r\n        GATE: () => detectedType === AnnotationBodyTypes.constantDeclaration,\r\n        ALT: () => $.SUBRULE($.constantDeclaration)\r\n      },\r\n      {\r\n        GATE: () => detectedType === AnnotationBodyTypes.classDeclaration,\r\n        ALT: () => $.SUBRULE($.classDeclaration)\r\n      },\r\n      {\r\n        GATE: () => detectedType === AnnotationBodyTypes.interfaceDeclaration,\r\n        ALT: () => $.SUBRULE($.interfaceDeclaration)\r\n      },\r\n      {\r\n        // No GATE is needed as this is LL(1)\r\n        ALT: () => $.CONSUME(t.Semicolon)\r\n      }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotationTypeElementDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "constantDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "interfaceDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Semicolon",
                "label": "';'",
                "idx": 0,
                "pattern": ";"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotationTypeElementDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotationTypeElementModifier);\r\n    });\r\n    $.CONSUME(t.Identifier);\r\n    $.CONSUME(t.LBrace);\r\n    $.CONSUME(t.RBrace);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.dims);\r\n    });\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.defaultValue);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotationTypeElementModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dims",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "defaultValue",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotationTypeElementModifier",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.annotation) },\r\n      { ALT: () => $.CONSUME(t.Public) },\r\n      { ALT: () => $.CONSUME(t.Abstract) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Abstract",
                "label": "'abstract'",
                "idx": 0,
                "pattern": "abstract"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "defaultValue",
    "orgText": "() => {\r\n    $.CONSUME(t.Default);\r\n    $.SUBRULE($.elementValue);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Default",
        "label": "'default'",
        "idx": 0,
        "pattern": "default"
      },
      {
        "type": "NonTerminal",
        "name": "elementValue",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotation",
    "orgText": "() => {\r\n    // TODO: performance optimization: implement optimized backtracking here.\r\n    $.OR([\r\n      {\r\n        GATE: $.BACKTRACK($.normalAnnotation),\r\n        ALT: () => $.SUBRULE($.normalAnnotation)\r\n      },\r\n      // \"singleElementAnnotation\" must appear before \"markerAnnotation\" due to common\r\n      // prefix.\r\n      {\r\n        GATE: $.BACKTRACK($.singleElementAnnotation),\r\n        ALT: () => $.SUBRULE($.singleElementAnnotation)\r\n      },\r\n      { ALT: () => $.SUBRULE($.markerAnnotation) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "normalAnnotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "singleElementAnnotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "markerAnnotation",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "normalAnnotation",
    "orgText": "() => {\r\n    $.CONSUME(t.At);\r\n    $.SUBRULE($.typeName);\r\n    $.CONSUME(t.LBrace);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.elementValuePairList);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "At",
        "label": "'@'",
        "idx": 0,
        "pattern": "@"
      },
      {
        "type": "NonTerminal",
        "name": "typeName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "elementValuePairList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "elementValuePairList",
    "orgText": "() => {\r\n    $.SUBRULE($.elementValuePair);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.elementValuePair);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "elementValuePair",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "elementValuePair",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "elementValuePair",
    "orgText": "() => {\r\n    $.CONSUME(t.Identifier);\r\n    $.CONSUME(t.Equals);\r\n    $.SUBRULE($.elementValue);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Terminal",
        "name": "Equals",
        "label": "'='",
        "idx": 0,
        "pattern": "="
      },
      {
        "type": "NonTerminal",
        "name": "elementValue",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "elementValue",
    "orgText": "() => {\r\n    const isSimpleElementValueAnnotation = this.BACKTRACK_LOOKAHEAD(\r\n      $.isSimpleElementValueAnnotation\r\n    );\r\n    $.OR([\r\n      // Spec Deviation: \"conditionalExpression\" replaced with \"expression\"\r\n      // Because we cannot differentiate between the two using fixed lookahead.\r\n      {\r\n        GATE: () => isSimpleElementValueAnnotation === false,\r\n        ALT: () => $.SUBRULE($.expression)\r\n      },\r\n      { ALT: () => $.SUBRULE($.elementValueArrayInitializer) },\r\n      {\r\n        GATE: () => isSimpleElementValueAnnotation === true,\r\n        ALT: () => $.SUBRULE($.annotation)\r\n      }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "expression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "elementValueArrayInitializer",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "elementValueArrayInitializer",
    "orgText": "() => {\r\n    $.CONSUME(t.LCurly);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.elementValueList);\r\n    });\r\n    $.OPTION2(() => {\r\n      $.CONSUME(t.Comma);\r\n    });\r\n    $.CONSUME(t.RCurly);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "elementValueList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "elementValueList",
    "orgText": "() => {\r\n    $.SUBRULE($.elementValue);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.elementValue);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "elementValue",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "elementValue",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "markerAnnotation",
    "orgText": "() => {\r\n    $.CONSUME(t.At);\r\n    $.SUBRULE($.typeName);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "At",
        "label": "'@'",
        "idx": 0,
        "pattern": "@"
      },
      {
        "type": "NonTerminal",
        "name": "typeName",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "singleElementAnnotation",
    "orgText": "() => {\r\n    $.CONSUME(t.At);\r\n    $.SUBRULE($.typeName);\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.elementValue);\r\n    $.CONSUME(t.RBrace);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "At",
        "label": "'@'",
        "idx": 0,
        "pattern": "@"
      },
      {
        "type": "NonTerminal",
        "name": "typeName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "elementValue",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "identifyInterfaceBodyDeclarationType",
    "orgText": "() => {\r\n    let nextTokenType = this.LA(1).tokenType;\r\n    if (nextTokenType === t.Semicolon) {\r\n      return InterfaceBodyTypes.semiColon;\r\n    }\r\n\r\n    // We have to look beyond the modifiers to distinguish between the declaration types.\r\n    $.MANY(() => {\r\n      // This alternation includes all possible modifiers for all types of \"interfaceMemberDeclaration\"\r\n      // Certain combinations are syntactically invalid, this is **not** checked here,\r\n      // Invalid combinations will cause a descriptive parsing error message to be\r\n      // Created inside the relevant parsing rules **after** this lookahead\r\n      // analysis.\r\n      $.OR([\r\n        { ALT: () => $.SUBRULE($.annotation) },\r\n        { ALT: () => $.CONSUME(t.Public) },\r\n        { ALT: () => $.CONSUME(t.Protected) },\r\n        { ALT: () => $.CONSUME(t.Private) },\r\n        { ALT: () => $.CONSUME(t.Static) },\r\n        { ALT: () => $.CONSUME(t.Final) },\r\n        { ALT: () => $.CONSUME(t.Abstract) },\r\n        { ALT: () => $.CONSUME(t.Default) },\r\n        { ALT: () => $.CONSUME(t.Strictfp) }\r\n      ]);\r\n    });\r\n\r\n    nextTokenType = this.LA(1).tokenType;\r\n    if (nextTokenType === t.Class || nextTokenType === t.Enum) {\r\n      return InterfaceBodyTypes.classDeclaration;\r\n    }\r\n    if (nextTokenType === t.Interface || nextTokenType === t.At) {\r\n      return InterfaceBodyTypes.interfaceDeclaration;\r\n    }\r\n    if (nextTokenType === t.Void || nextTokenType === t.Less) {\r\n      // method with result type \"void\"\r\n      return InterfaceBodyTypes.interfaceMethodDeclaration;\r\n    }\r\n\r\n    // Only constant or interfaceMethod declarations may be valid at this point.\r\n    // All other alternatives should have been attempted.\r\n    // **both** start with \"unannType\"\r\n    this.SUBRULE($.unannType);\r\n\r\n    nextTokenType = this.LA(1).tokenType;\r\n    const nextNextTokenType = this.LA(2).tokenType;\r\n    // \"foo(...\" --> look like method start\r\n    if (nextTokenType === t.Identifier && nextNextTokenType === t.LBrace) {\r\n      return InterfaceBodyTypes.interfaceMethodDeclaration;\r\n    }\r\n    // a valid constant\r\n    if (nextTokenType === t.Identifier) {\r\n      return InterfaceBodyTypes.constantDeclaration;\r\n    }\r\n    return InterfaceBodyTypes.unknown;\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "annotation",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Public",
                    "label": "'public'",
                    "idx": 0,
                    "pattern": "public"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Protected",
                    "label": "'protected'",
                    "idx": 0,
                    "pattern": "protected"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Private",
                    "label": "'private'",
                    "idx": 0,
                    "pattern": "private"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Static",
                    "label": "'static'",
                    "idx": 0,
                    "pattern": "static"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Final",
                    "label": "'final'",
                    "idx": 0,
                    "pattern": "final"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Abstract",
                    "label": "'abstract'",
                    "idx": 0,
                    "pattern": "abstract"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Default",
                    "label": "'default'",
                    "idx": 0,
                    "pattern": "default"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Strictfp",
                    "label": "'strictfp'",
                    "idx": 0,
                    "pattern": "strictfp"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "identifyAnnotationBodyDeclarationType",
    "orgText": "() => {\r\n    let nextTokenType = this.LA(1).tokenType;\r\n    if (nextTokenType === t.Semicolon) {\r\n      return AnnotationBodyTypes.semiColon;\r\n    }\r\n\r\n    // We have to look beyond the modifiers to distinguish between the declaration types.\r\n    $.MANY(() => {\r\n      // This alternation includes all possible modifiers for all types of \"annotationTypeMemberDeclaration\"\r\n      // Certain combinations are syntactically invalid, this is **not** checked here,\r\n      // Invalid combinations will cause a descriptive parsing error message to be\r\n      // Created inside the relevant parsing rules **after** this lookahead\r\n      // analysis.\r\n      $.OR([\r\n        { ALT: () => $.SUBRULE($.annotation) },\r\n        { ALT: () => $.CONSUME(t.Public) },\r\n        { ALT: () => $.CONSUME(t.Protected) },\r\n        { ALT: () => $.CONSUME(t.Private) },\r\n        { ALT: () => $.CONSUME(t.Abstract) },\r\n        { ALT: () => $.CONSUME(t.Static) },\r\n        { ALT: () => $.CONSUME(t.Final) },\r\n        { ALT: () => $.CONSUME(t.Strictfp) }\r\n      ]);\r\n    });\r\n\r\n    nextTokenType = this.LA(1).tokenType;\r\n    if (nextTokenType === t.Class || nextTokenType === t.Enum) {\r\n      return AnnotationBodyTypes.classDeclaration;\r\n    }\r\n    if (nextTokenType === t.Interface || nextTokenType === t.At) {\r\n      return AnnotationBodyTypes.interfaceDeclaration;\r\n    }\r\n\r\n    // Only constant or annotationTypeElement declarations may be valid at this point.\r\n    // All other alternatives should have been attempted.\r\n    // **both** start with \"unannType\"\r\n    this.SUBRULE($.unannType);\r\n\r\n    nextTokenType = this.LA(1).tokenType;\r\n    const nextNextTokenType = this.LA(2).tokenType;\r\n    // \"foo(...\" --> look like annotationTypeElement start\r\n    if (nextTokenType === t.Identifier && nextNextTokenType === t.LBrace) {\r\n      return AnnotationBodyTypes.annotationTypeElementDeclaration;\r\n    }\r\n    // a valid constant\r\n    if (nextTokenType === t.Identifier) {\r\n      return AnnotationBodyTypes.constantDeclaration;\r\n    }\r\n    return AnnotationBodyTypes.unknown;\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "annotation",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Public",
                    "label": "'public'",
                    "idx": 0,
                    "pattern": "public"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Protected",
                    "label": "'protected'",
                    "idx": 0,
                    "pattern": "protected"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Private",
                    "label": "'private'",
                    "idx": 0,
                    "pattern": "private"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Abstract",
                    "label": "'abstract'",
                    "idx": 0,
                    "pattern": "abstract"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Static",
                    "label": "'static'",
                    "idx": 0,
                    "pattern": "static"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Final",
                    "label": "'final'",
                    "idx": 0,
                    "pattern": "final"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Strictfp",
                    "label": "'strictfp'",
                    "idx": 0,
                    "pattern": "strictfp"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "identifyInterfaceType",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.interfaceModifier);\r\n    });\r\n    const nextTokenType = $.LA(1).tokenType;\r\n\r\n    switch (nextTokenType) {\r\n      case t.Interface:\r\n        return InterfaceType.normalInterfaceDeclaration;\r\n      // TODO: an interfaceModifier may start with an \"@\" (annotation)\r\n      //   we need to check more specifically for \"@interface\" two tokens sequence\r\n      //   specifically in the repetition above (add gate?)\r\n      case t.At:\r\n        return InterfaceType.annotationTypeDeclaration;\r\n      default:\r\n        return InterfaceType.unknown;\r\n    }\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "interfaceModifier",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isSimpleElementValueAnnotation",
    "orgText": "() => {\r\n    $.SUBRULE($.annotation);\r\n    const nextTokenType = this.LA(1).tokenType;\r\n    switch (nextTokenType) {\r\n      // annotation in \"ElementValue\" would be followed by one of those\r\n      // any other TokenType would indicate it is an annotation in a \"referenceType\"\r\n      // as part of a \"methodReference\" in \"primary\"\r\n      case t.Comma:\r\n      case t.Semicolon:\r\n      case t.RCurly:\r\n      case t.RBrace:\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "annotation",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "arrayInitializer",
    "orgText": "() => {\r\n    $.CONSUME(t.LCurly);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.variableInitializerList);\r\n    });\r\n    $.OPTION2(() => {\r\n      $.CONSUME(t.Comma);\r\n    });\r\n    $.CONSUME(t.RCurly);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableInitializerList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableInitializerList",
    "orgText": "() => {\r\n    $.SUBRULE($.variableInitializer);\r\n    $.MANY({\r\n      // The optional last \"Comma\" of an \"arrayInitializer\"\r\n      GATE: () => this.LA(2).tokenType !== t.RCurly,\r\n      DEF: () => {\r\n        $.CONSUME(t.Comma);\r\n        $.SUBRULE2($.variableInitializer);\r\n      }\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "variableInitializer",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "variableInitializer",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "block",
    "orgText": "() => {\r\n    $.CONSUME(t.LCurly);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.blockStatements);\r\n    });\r\n    $.CONSUME(t.RCurly);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "blockStatements",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "blockStatements",
    "orgText": "() => {\r\n    $.SUBRULE($.blockStatement);\r\n    $.MANY(() => {\r\n      $.SUBRULE2($.blockStatement);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "blockStatement",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "blockStatement",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "blockStatement",
    "orgText": "() => {\r\n    const isLocalVariableDeclaration = this.BACKTRACK_LOOKAHEAD(\r\n      $.isLocalVariableDeclaration\r\n    );\r\n    $.OR([\r\n      {\r\n        GATE: () => isLocalVariableDeclaration,\r\n        ALT: () => $.SUBRULE($.localVariableDeclarationStatement)\r\n      },\r\n      {\r\n        ALT: () => $.SUBRULE($.classDeclaration)\r\n      },\r\n      { ALT: () => $.SUBRULE($.statement) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "localVariableDeclarationStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "statement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "localVariableDeclarationStatement",
    "orgText": "() => {\r\n    $.SUBRULE($.localVariableDeclaration);\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "localVariableDeclaration",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "localVariableDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.variableModifier);\r\n    });\r\n    $.SUBRULE($.localVariableType);\r\n    $.SUBRULE($.variableDeclaratorList);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "localVariableType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorList",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "localVariableType",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.unannType) },\r\n      { ALT: () => $.CONSUME(t.Var) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Var",
                "label": "'var'",
                "idx": 0,
                "pattern": "var"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "statement",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.statementWithoutTrailingSubstatement) },\r\n      { ALT: () => $.SUBRULE($.labeledStatement) },\r\n      // Spec deviation: combined \"IfThenStatement\" and \"IfThenElseStatement\"\r\n      { ALT: () => $.SUBRULE($.ifStatement) },\r\n      { ALT: () => $.SUBRULE($.whileStatement) },\r\n      { ALT: () => $.SUBRULE($.forStatement) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "statementWithoutTrailingSubstatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "labeledStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ifStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "whileStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "forStatement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "statementWithoutTrailingSubstatement",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.block) },\r\n      { ALT: () => $.SUBRULE($.emptyStatement) },\r\n      { ALT: () => $.SUBRULE($.expressionStatement) },\r\n      { ALT: () => $.SUBRULE($.assertStatement) },\r\n      { ALT: () => $.SUBRULE($.switchStatement) },\r\n      { ALT: () => $.SUBRULE($.doStatement) },\r\n      { ALT: () => $.SUBRULE($.breakStatement) },\r\n      { ALT: () => $.SUBRULE($.continueStatement) },\r\n      { ALT: () => $.SUBRULE($.returnStatement) },\r\n      { ALT: () => $.SUBRULE($.synchronizedStatement) },\r\n      { ALT: () => $.SUBRULE($.throwStatement) },\r\n      { ALT: () => $.SUBRULE($.tryStatement) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "block",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "emptyStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "expressionStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "assertStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "switchStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "doStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "breakStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "continueStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "returnStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "synchronizedStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "throwStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "tryStatement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "emptyStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "labeledStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.Identifier);\r\n    $.CONSUME(t.Colon);\r\n    $.SUBRULE($.statement);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Terminal",
        "name": "Colon",
        "label": "':'",
        "idx": 0,
        "pattern": ":"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "expressionStatement",
    "orgText": "() => {\r\n    $.SUBRULE($.statementExpression);\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "statementExpression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "statementExpression",
    "orgText": "() => {\r\n    // Spec deviation: The many alternatives here were replaced with\r\n    //                 the \"expression\" rule as it contains them all,\r\n    //                 and distinguishing between the alternatives cannot be done\r\n    //                 using a fixed lookahead.\r\n    // TODO: verify the resulting expression is one of the valid alternatives?\r\n    $.SUBRULE($.expression);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ifStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.If);\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.expression);\r\n    $.CONSUME(t.RBrace);\r\n    $.SUBRULE($.statement);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.Else);\r\n      $.SUBRULE2($.statement);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "If",
        "label": "'if'",
        "idx": 0,
        "pattern": "if"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Else",
            "label": "'else'",
            "idx": 0,
            "pattern": "else"
          },
          {
            "type": "NonTerminal",
            "name": "statement",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "assertStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.Assert);\r\n    $.SUBRULE($.expression);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.Colon);\r\n      $.SUBRULE2($.expression);\r\n    });\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Assert",
        "label": "'assert'",
        "idx": 0,
        "pattern": "assert"
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Colon",
            "label": "':'",
            "idx": 0,
            "pattern": ":"
          },
          {
            "type": "NonTerminal",
            "name": "expression",
            "idx": 2
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "switchStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.Switch);\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.expression);\r\n    $.CONSUME(t.RBrace);\r\n    $.SUBRULE($.switchBlock);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Switch",
        "label": "'switch'",
        "idx": 0,
        "pattern": "switch"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "switchBlock",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "switchBlock",
    "orgText": "() => {\r\n    $.CONSUME(t.LCurly);\r\n    $.MANY(() => {\r\n      // Spec Deviation: refactored \"switchBlock\" for easy post-processing\r\n      //                 each case and block together in the same rule.\r\n      $.SUBRULE($.switchCase);\r\n    });\r\n    $.CONSUME(t.RCurly);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "switchCase",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "switchCase",
    "orgText": "() => {\r\n    $.SUBRULE($.switchLabel);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.blockStatements);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "switchLabel",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "blockStatements",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "switchLabel",
    "orgText": "() => {\r\n    $.OR([\r\n      {\r\n        ALT: () => {\r\n          $.CONSUME(t.Case);\r\n          $.SUBRULE($.constantExpression);\r\n          $.CONSUME(t.Colon);\r\n        }\r\n      },\r\n      // SPEC Deviation: the variant with \"enumConstantName\" was removed\r\n      // as it can be matched by the \"constantExpression\" variant\r\n      // the distinction is semantic not syntactic.\r\n      {\r\n        ALT: () => {\r\n          $.CONSUME(t.Default);\r\n          $.CONSUME3(t.Colon);\r\n        }\r\n      }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Case",
                "label": "'case'",
                "idx": 0,
                "pattern": "case"
              },
              {
                "type": "NonTerminal",
                "name": "constantExpression",
                "idx": 0
              },
              {
                "type": "Terminal",
                "name": "Colon",
                "label": "':'",
                "idx": 0,
                "pattern": ":"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Default",
                "label": "'default'",
                "idx": 0,
                "pattern": "default"
              },
              {
                "type": "Terminal",
                "name": "Colon",
                "label": "':'",
                "idx": 3,
                "pattern": ":"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumConstantName",
    "orgText": "() => {\r\n    $.CONSUME(t.Identifier);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "whileStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.While);\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.expression);\r\n    $.CONSUME(t.RBrace);\r\n    $.SUBRULE($.statement);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "While",
        "label": "'while'",
        "idx": 0,
        "pattern": "while"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "doStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.Do);\r\n    $.SUBRULE($.statement);\r\n    $.CONSUME(t.While);\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.expression);\r\n    $.CONSUME(t.RBrace);\r\n    $.CONSUME(t.Semicolon);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Do",
        "label": "'do'",
        "idx": 0,
        "pattern": "do"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "While",
        "label": "'while'",
        "idx": 0,
        "pattern": "while"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "forStatement",
    "orgText": "() => {\r\n    $.OR([\r\n      {\r\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isBasicForStatement),\r\n        ALT: () => $.SUBRULE($.basicForStatement)\r\n      },\r\n      { ALT: () => $.SUBRULE($.enhancedForStatement) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "basicForStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "enhancedForStatement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "basicForStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.For);\r\n    $.CONSUME(t.LBrace);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.forInit);\r\n    });\r\n    $.CONSUME(t.Semicolon);\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.expression);\r\n    });\r\n    $.CONSUME2(t.Semicolon);\r\n    $.OPTION3(() => {\r\n      $.SUBRULE($.forUpdate);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n    $.SUBRULE($.statement);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "For",
        "label": "'for'",
        "idx": 0,
        "pattern": "for"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "forInit",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "expression",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 2,
        "pattern": ";"
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "forUpdate",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "forInit",
    "orgText": "() => {\r\n    $.OR([\r\n      {\r\n        GATE: () => $.BACKTRACK_LOOKAHEAD($.isLocalVariableDeclaration),\r\n        ALT: () => $.SUBRULE($.localVariableDeclaration)\r\n      },\r\n      { ALT: () => $.SUBRULE($.statementExpressionList) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "localVariableDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "statementExpressionList",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "forUpdate",
    "orgText": "() => {\r\n    $.SUBRULE($.statementExpressionList);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "statementExpressionList",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "statementExpressionList",
    "orgText": "() => {\r\n    $.SUBRULE($.statementExpression);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.statementExpression);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "statementExpression",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "statementExpression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enhancedForStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.For);\r\n    $.CONSUME(t.LBrace);\r\n    $.MANY(() => {\r\n      $.SUBRULE($.variableModifier);\r\n    });\r\n    $.SUBRULE($.localVariableType);\r\n    $.SUBRULE($.variableDeclaratorId);\r\n    $.CONSUME(t.Colon);\r\n    $.SUBRULE($.expression);\r\n    $.CONSUME(t.RBrace);\r\n    $.SUBRULE($.statement);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "For",
        "label": "'for'",
        "idx": 0,
        "pattern": "for"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "localVariableType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Colon",
        "label": "':'",
        "idx": 0,
        "pattern": ":"
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "breakStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.Break);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.Identifier);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Break",
        "label": "'break'",
        "idx": 0,
        "pattern": "break"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 0,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "continueStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.Continue);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.Identifier);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Continue",
        "label": "'continue'",
        "idx": 0,
        "pattern": "continue"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 0,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "returnStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.Return);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.expression);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Return",
        "label": "'return'",
        "idx": 0,
        "pattern": "return"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "expression",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "throwStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.Throw);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.expression);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Throw",
        "label": "'throw'",
        "idx": 0,
        "pattern": "throw"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "expression",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "synchronizedStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.Synchronized);\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.expression);\r\n    $.CONSUME(t.RBrace);\r\n    $.SUBRULE($.block);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Synchronized",
        "label": "'synchronized'",
        "idx": 0,
        "pattern": "synchronized"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "tryStatement",
    "orgText": "() => {\r\n    $.OR([\r\n      {\r\n        ALT: () => {\r\n          $.CONSUME(t.Try);\r\n          $.SUBRULE($.block);\r\n          $.OR2([\r\n            {\r\n              ALT: () => {\r\n                $.SUBRULE($.catches);\r\n                $.OPTION(() => {\r\n                  $.SUBRULE($.finally);\r\n                });\r\n              }\r\n            },\r\n            { ALT: () => $.SUBRULE2($.finally) }\r\n          ]);\r\n        }\r\n      },\r\n      { ALT: () => $.SUBRULE($.tryWithResourcesStatement) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Try",
                "label": "'try'",
                "idx": 0,
                "pattern": "try"
              },
              {
                "type": "NonTerminal",
                "name": "block",
                "idx": 0
              },
              {
                "type": "Alternation",
                "idx": 2,
                "definition": [
                  {
                    "type": "Flat",
                    "definition": [
                      {
                        "type": "NonTerminal",
                        "name": "catches",
                        "idx": 0
                      },
                      {
                        "type": "Option",
                        "idx": 0,
                        "definition": [
                          {
                            "type": "NonTerminal",
                            "name": "finally",
                            "idx": 0
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "type": "Flat",
                    "definition": [
                      {
                        "type": "NonTerminal",
                        "name": "finally",
                        "idx": 2
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "tryWithResourcesStatement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "catches",
    "orgText": "() => {\r\n    $.SUBRULE($.catchClause);\r\n    $.MANY(() => {\r\n      $.SUBRULE2($.catchClause);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "catchClause",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "catchClause",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "catchClause",
    "orgText": "() => {\r\n    $.CONSUME(t.Catch);\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.catchFormalParameter);\r\n    $.CONSUME(t.RBrace);\r\n    $.SUBRULE($.block);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Catch",
        "label": "'catch'",
        "idx": 0,
        "pattern": "catch"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "catchFormalParameter",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "catchFormalParameter",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.variableModifier);\r\n    });\r\n    $.SUBRULE($.catchType);\r\n    $.SUBRULE($.variableDeclaratorId);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "catchType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "catchType",
    "orgText": "() => {\r\n    $.SUBRULE($.unannClassType);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Or);\r\n      $.SUBRULE2($.classType);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "unannClassType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Or",
            "label": "'|'",
            "idx": 0,
            "pattern": "|"
          },
          {
            "type": "NonTerminal",
            "name": "classType",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "finally",
    "orgText": "() => {\r\n    $.CONSUME(t.Finally);\r\n    $.SUBRULE($.block);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Finally",
        "label": "'finally'",
        "idx": 0,
        "pattern": "finally"
      },
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "tryWithResourcesStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.Try);\r\n    $.SUBRULE($.resourceSpecification);\r\n    $.SUBRULE($.block);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.catches);\r\n    });\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.finally);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Try",
        "label": "'try'",
        "idx": 0,
        "pattern": "try"
      },
      {
        "type": "NonTerminal",
        "name": "resourceSpecification",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "catches",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "finally",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "resourceSpecification",
    "orgText": "() => {\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.resourceList);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.Semicolon);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "resourceList",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Semicolon",
            "label": "';'",
            "idx": 0,
            "pattern": ";"
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "resourceList",
    "orgText": "() => {\r\n    $.SUBRULE($.resource);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Semicolon);\r\n      $.SUBRULE2($.resource);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "resource",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Semicolon",
            "label": "';'",
            "idx": 0,
            "pattern": ";"
          },
          {
            "type": "NonTerminal",
            "name": "resource",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "resource",
    "orgText": "() => {\r\n    $.OR([\r\n      {\r\n        GATE: $.BACKTRACK($.resourceInit),\r\n        // Spec Deviation: extracted this alternative to \"resourceInit\"\r\n        //                 to enable backtracking.\r\n        ALT: () => $.SUBRULE($.resourceInit)\r\n      },\r\n      { ALT: () => $.SUBRULE($.variableAccess) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "resourceInit",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "variableAccess",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "resourceInit",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.variableModifier);\r\n    });\r\n    $.SUBRULE($.localVariableType);\r\n    $.CONSUME(t.Identifier);\r\n    $.CONSUME(t.Equals);\r\n    $.SUBRULE($.expression);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "localVariableType",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Terminal",
        "name": "Equals",
        "label": "'='",
        "idx": 0,
        "pattern": "="
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableAccess",
    "orgText": "() => {\r\n    // Spec Deviation: both \"expressionName\" and \"fieldAccess\" can be parsed\r\n    //                 by the \"primary\" rule\r\n    // TODO: verify that the primary is a fieldAccess or an expressionName.\r\n    $.SUBRULE($.primary);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "primary",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isBasicForStatement",
    "orgText": "() => {\r\n    $.CONSUME(t.For);\r\n    $.CONSUME(t.LBrace);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.forInit);\r\n    });\r\n    $.CONSUME(t.Semicolon);\r\n    // consuming the first semiColon distinguishes between\r\n    // \"basic\" and \"enhanced\" for statements\r\n    return true;\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "For",
        "label": "'for'",
        "idx": 0,
        "pattern": "for"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "forInit",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isLocalVariableDeclaration",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.variableModifier);\r\n    });\r\n    $.SUBRULE($.localVariableType);\r\n    $.SUBRULE($.variableDeclaratorId);\r\n\r\n    const nextTokenType = this.LA(1).tokenType;\r\n    switch (nextTokenType) {\r\n      // Int x;\r\n      case t.Semicolon:\r\n      // Int x, y, z;\r\n      case t.Comma:\r\n      // Int x = 5;\r\n      case t.Equals:\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "localVariableType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constantExpression",
    "orgText": "() => {\r\n    $.SUBRULE($.expression);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "expression",
    "orgText": "() => {\r\n    $.OR([\r\n      {\r\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isLambdaExpression),\r\n        ALT: () => $.SUBRULE($.lambdaExpression)\r\n      },\r\n      { ALT: () => $.SUBRULE($.assignmentExpression) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "lambdaExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "assignmentExpression",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaExpression",
    "orgText": "() => {\r\n    $.SUBRULE($.lambdaParameters);\r\n    $.CONSUME(t.Arrow);\r\n    $.SUBRULE($.lambdaBody);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "lambdaParameters",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Arrow",
        "label": "'->'",
        "idx": 0,
        "pattern": "->"
      },
      {
        "type": "NonTerminal",
        "name": "lambdaBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaParameters",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.lambdaParametersWithBraces) },\r\n      { ALT: () => $.CONSUME(t.Identifier) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "lambdaParametersWithBraces",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Identifier",
                "label": "Identifier",
                "idx": 0,
                "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaParametersWithBraces",
    "orgText": "() => {\r\n    $.CONSUME(t.LBrace);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.lambdaParameterList);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "lambdaParameterList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaParameterList",
    "orgText": "() => {\r\n    $.OR([\r\n      {\r\n        GATE: () => {\r\n          const nextTokType = this.LA(1).tokenType;\r\n          const nextNextTokType = this.LA(2).tokenType;\r\n          return (\r\n            nextTokType === t.Identifier &&\r\n            (nextNextTokType === t.RBrace || nextNextTokType === t.Comma)\r\n          );\r\n        },\r\n        ALT: () => $.SUBRULE($.inferredLambdaParameterList)\r\n      },\r\n      { ALT: () => $.SUBRULE($.explicitLambdaParameterList) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "inferredLambdaParameterList",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "explicitLambdaParameterList",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "inferredLambdaParameterList",
    "orgText": "() => {\r\n    $.CONSUME(t.Identifier);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.CONSUME2(t.Identifier);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "explicitLambdaParameterList",
    "orgText": "() => {\r\n    $.SUBRULE($.lambdaParameter);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.lambdaParameter);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "lambdaParameter",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "lambdaParameter",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaParameter",
    "orgText": "() => {\r\n    // TODO: performance, investigate the performance boost that could\r\n    //       be gained by refactoring out the backtracking.\r\n    $.OR([\r\n      {\r\n        GATE: $.BACKTRACK($.regularLambdaParameter),\r\n        ALT: () => $.SUBRULE($.regularLambdaParameter)\r\n      },\r\n      { ALT: () => $.SUBRULE($.variableArityParameter) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "regularLambdaParameter",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "variableArityParameter",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "regularLambdaParameter",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.variableModifier);\r\n    });\r\n    $.SUBRULE($.lambdaParameterType);\r\n    $.SUBRULE($.variableDeclaratorId);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "lambdaParameterType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaParameterType",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.unannType) },\r\n      { ALT: () => $.CONSUME(t.Var) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Var",
                "label": "'var'",
                "idx": 0,
                "pattern": "var"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaBody",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.expression) },\r\n      { ALT: () => $.SUBRULE($.block) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "expression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "block",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "assignmentExpression",
    "orgText": "() => {\r\n    $.SUBRULE($.binaryExpression);\r\n    $.OPTION(() => {\r\n      $.CONSUME(t.QuestionMark);\r\n      $.SUBRULE($.assignmentExpression);\r\n      $.CONSUME(t.Colon);\r\n      $.SUBRULE2($.assignmentExpression);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "binaryExpression",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "QuestionMark",
            "label": "'?'",
            "idx": 0,
            "pattern": "?"
          },
          {
            "type": "NonTerminal",
            "name": "assignmentExpression",
            "idx": 0
          },
          {
            "type": "Terminal",
            "name": "Colon",
            "label": "':'",
            "idx": 0,
            "pattern": ":"
          },
          {
            "type": "NonTerminal",
            "name": "assignmentExpression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "binaryExpression",
    "orgText": "() => {\r\n    $.SUBRULE($.unaryExpression);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.BinaryOperator);\r\n      $.SUBRULE2($.unaryExpression);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "unaryExpression",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "BinaryOperator",
            "label": "'BinaryOperator'",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          },
          {
            "type": "NonTerminal",
            "name": "unaryExpression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unaryExpression",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.CONSUME(t.UnaryPrefixOperator);\r\n    });\r\n    $.SUBRULE($.primary);\r\n    $.MANY2(() => {\r\n      $.CONSUME(t.UnarySuffixOperator);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "UnaryPrefixOperator",
            "label": "'UnaryPrefixOperator'",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "primary",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "UnarySuffixOperator",
            "label": "'UnarySuffixOperator'",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unaryExpressionNotPlusMinus",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.CONSUME(t.UnaryPrefixOperatorNotPlusMinus);\r\n    });\r\n    $.SUBRULE($.primary);\r\n    $.MANY2(() => {\r\n      $.CONSUME(t.UnarySuffixOperator);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "UnaryPrefixOperatorNotPlusMinus",
            "label": "'UnaryPrefixOperatorNotPlusMinus'",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "primary",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "UnarySuffixOperator",
            "label": "'UnarySuffixOperator'",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "primary",
    "orgText": "() => {\r\n    $.SUBRULE($.primaryPrefix);\r\n    $.MANY(() => {\r\n      $.SUBRULE($.primarySuffix);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "primaryPrefix",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "primarySuffix",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "primaryPrefix",
    "orgText": "() => {\r\n    let isCastExpression = false;\r\n    if ($.LA(1).tokenType === t.LBrace) {\r\n      isCastExpression = this.BACKTRACK_LOOKAHEAD($.isCastExpression);\r\n    }\r\n\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.literal) },\r\n      { ALT: () => $.CONSUME(t.This) },\r\n      { ALT: () => $.CONSUME(t.Void) },\r\n      // should be extracted to primitive type with optional dims suffix?\r\n      { ALT: () => $.SUBRULE($.numericType) },\r\n      { ALT: () => $.CONSUME(t.Boolean) },\r\n      { ALT: () => $.SUBRULE($.fqnOrRefType) },\r\n      {\r\n        GATE: () => isCastExpression,\r\n        ALT: () => $.SUBRULE($.castExpression)\r\n      },\r\n      { ALT: () => $.SUBRULE($.parenthesisExpression) },\r\n      { ALT: () => $.SUBRULE($.newExpression) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "literal",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "This",
                "label": "'this'",
                "idx": 0,
                "pattern": "this"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Void",
                "label": "'void'",
                "idx": 0,
                "pattern": "void"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "numericType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Boolean",
                "label": "'boolean'",
                "idx": 0,
                "pattern": "boolean"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "fqnOrRefType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "castExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "parenthesisExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "newExpression",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "primarySuffix",
    "orgText": "() => {\r\n    $.OR([\r\n      {\r\n        ALT: () => {\r\n          $.CONSUME(t.Dot);\r\n          $.OR2([\r\n            { ALT: () => $.CONSUME(t.This) },\r\n            {\r\n              ALT: () => $.SUBRULE($.unqualifiedClassInstanceCreationExpression)\r\n            },\r\n            // TODO: this should probably not be preceded by a \"dot\"\r\n            { ALT: () => $.CONSUME(t.Identifier) }\r\n          ]);\r\n        }\r\n      },\r\n      { ALT: () => $.SUBRULE($.methodInvocationSuffix) },\r\n      { ALT: () => $.SUBRULE($.classLiteralSuffix) },\r\n      { ALT: () => $.SUBRULE($.arrayAccessSuffix) },\r\n      { ALT: () => $.SUBRULE($.methodReferenceSuffix) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Dot",
                "label": "'.'",
                "idx": 0,
                "pattern": "."
              },
              {
                "type": "Alternation",
                "idx": 2,
                "definition": [
                  {
                    "type": "Flat",
                    "definition": [
                      {
                        "type": "Terminal",
                        "name": "This",
                        "label": "'this'",
                        "idx": 0,
                        "pattern": "this"
                      }
                    ]
                  },
                  {
                    "type": "Flat",
                    "definition": [
                      {
                        "type": "NonTerminal",
                        "name": "unqualifiedClassInstanceCreationExpression",
                        "idx": 0
                      }
                    ]
                  },
                  {
                    "type": "Flat",
                    "definition": [
                      {
                        "type": "Terminal",
                        "name": "Identifier",
                        "label": "Identifier",
                        "idx": 0,
                        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "methodInvocationSuffix",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classLiteralSuffix",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "arrayAccessSuffix",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "methodReferenceSuffix",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "fqnOrRefType",
    "orgText": "() => {\r\n    $.SUBRULE($.fqnOrRefTypePart);\r\n\r\n    $.MANY2({\r\n      // \".class\" is a classLiteralSuffix\r\n      GATE: () => this.LA(2).tokenType !== t.Class,\r\n      DEF: () => {\r\n        $.CONSUME(t.Dot);\r\n        $.SUBRULE2($.fqnOrRefTypePart);\r\n      }\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "fqnOrRefTypePart",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "NonTerminal",
            "name": "fqnOrRefTypePart",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "fqnOrRefTypePart",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotation);\r\n    });\r\n\r\n    $.OPTION({\r\n      NAME: \"$methodTypeArguments\",\r\n      DEF: () => {\r\n        $.SUBRULE2($.typeArguments);\r\n      }\r\n    });\r\n\r\n    $.OR([\r\n      { ALT: () => $.CONSUME(t.Identifier) },\r\n      { ALT: () => $.CONSUME(t.Super) }\r\n    ]);\r\n\r\n    let isRefTypeInMethodRef = false;\r\n    // Performance optimization, only perform this backtracking when a '<' is found\r\n    // TODO: performance optimization evaluation: avoid doing this backtracking for every \"<\" encountered.\r\n    //       we could do it once (using global state) per \"fqnOrRefType\"\r\n    // We could do it only once for\r\n    if ($.LA(1).tokenType === t.Less) {\r\n      isRefTypeInMethodRef = this.BACKTRACK_LOOKAHEAD($.isRefTypeInMethodRef);\r\n    }\r\n\r\n    $.OPTION2({\r\n      NAME: \"$classTypeArguments\",\r\n      // unrestricted typeArguments here would create an ambiguity with \"LessThan\" operator\r\n      // e.g: \"var x = a < b;\"\r\n      // The \"<\" would be parsed as the beginning of a \"typeArguments\"\r\n      // and we will get an error: \"expecting '>' but found: ';'\"\r\n      GATE: () => isRefTypeInMethodRef,\r\n      DEF: () => {\r\n        $.SUBRULE3($.typeArguments);\r\n      }\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 2
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Identifier",
                "label": "Identifier",
                "idx": 0,
                "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Super",
                "label": "'super'",
                "idx": 0,
                "pattern": "super"
              }
            ]
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 3
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "parenthesisExpression",
    "orgText": "() => {\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.expression);\r\n    $.CONSUME(t.RBrace);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "castExpression",
    "orgText": "() => {\r\n    $.OR([\r\n      {\r\n        // TODO: performance: can avoid backtracking again here, parent rule could have this information\r\n        //       when it checks isCastExpression (refactor needed)\r\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isPrimitiveCastExpression),\r\n        ALT: () => $.SUBRULE($.primitiveCastExpression)\r\n      },\r\n      { ALT: () => $.SUBRULE($.referenceTypeCastExpression) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "primitiveCastExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "referenceTypeCastExpression",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "primitiveCastExpression",
    "orgText": "() => {\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.primitiveType);\r\n    $.CONSUME(t.RBrace);\r\n    $.SUBRULE($.unaryExpression);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "primitiveType",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "unaryExpression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "referenceTypeCastExpression",
    "orgText": "() => {\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.referenceType);\r\n    $.MANY(() => {\r\n      $.SUBRULE($.additionalBound);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n    $.OR([\r\n      {\r\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isLambdaExpression),\r\n        ALT: () => $.SUBRULE($.lambdaExpression)\r\n      },\r\n      { ALT: () => $.SUBRULE($.unaryExpressionNotPlusMinus) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "referenceType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "additionalBound",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "lambdaExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unaryExpressionNotPlusMinus",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "newExpression",
    "orgText": "() => {\r\n    const type = this.BACKTRACK_LOOKAHEAD($.identifyNewExpressionType);\r\n\r\n    $.OR([\r\n      {\r\n        GATE: () => type === newExpressionTypes.arrayCreationExpression,\r\n        ALT: () => $.SUBRULE($.arrayCreationExpression)\r\n      },\r\n      {\r\n        GATE: () =>\r\n          type ===\r\n          newExpressionTypes.unqualifiedClassInstanceCreationExpression,\r\n        ALT: () => $.SUBRULE($.unqualifiedClassInstanceCreationExpression)\r\n      }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "arrayCreationExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unqualifiedClassInstanceCreationExpression",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unqualifiedClassInstanceCreationExpression",
    "orgText": "() => {\r\n    $.CONSUME(t.New);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeArguments);\r\n    });\r\n    $.SUBRULE($.classOrInterfaceTypeToInstantiate);\r\n    $.CONSUME(t.LBrace);\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.argumentList);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n    $.OPTION3(() => {\r\n      $.SUBRULE($.classBody);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "New",
        "label": "'new'",
        "idx": 0,
        "pattern": "new"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "classOrInterfaceTypeToInstantiate",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "argumentList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classBody",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classOrInterfaceTypeToInstantiate",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotation);\r\n    });\r\n    $.CONSUME(t.Identifier);\r\n    $.MANY2(() => {\r\n      $.CONSUME(t.Dot);\r\n      $.MANY3(() => {\r\n        $.SUBRULE2($.annotation);\r\n      });\r\n      $.CONSUME2(t.Identifier);\r\n    });\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeArgumentsOrDiamond);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0,
        "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Repetition",
            "idx": 3,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 2
              }
            ]
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2,
            "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
          }
        ]
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArgumentsOrDiamond",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeArgumentsOrDiamond",
    "orgText": "() => {\r\n    $.OR([\r\n      { ALT: () => $.SUBRULE($.diamond) },\r\n      { ALT: () => $.SUBRULE($.typeArguments) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "diamond",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "typeArguments",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "diamond",
    "orgText": "() => {\r\n    $.CONSUME(t.Less);\r\n    $.CONSUME(t.Greater);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Less",
        "label": "'<'",
        "idx": 0,
        "pattern": "<"
      },
      {
        "type": "Terminal",
        "name": "Greater",
        "label": "'>'",
        "idx": 0,
        "pattern": ">"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodInvocationSuffix",
    "orgText": "() => {\r\n    $.CONSUME(t.LBrace);\r\n    $.OPTION2(() => {\r\n      $.SUBRULE($.argumentList);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "argumentList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "argumentList",
    "orgText": "() => {\r\n    $.SUBRULE($.expression);\r\n    $.MANY(() => {\r\n      $.CONSUME(t.Comma);\r\n      $.SUBRULE2($.expression);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "expression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "arrayCreationExpression",
    "orgText": "() => {\r\n    $.CONSUME(t.New);\r\n    $.OR([\r\n      {\r\n        GATE: $.BACKTRACK($.primitiveType),\r\n        ALT: () => $.SUBRULE($.primitiveType)\r\n      },\r\n      { ALT: () => $.SUBRULE($.classOrInterfaceType) }\r\n    ]);\r\n\r\n    $.OR2([\r\n      {\r\n        GATE: $.BACKTRACK($.arrayCreationDefaultInitSuffix),\r\n        ALT: () => $.SUBRULE($.arrayCreationDefaultInitSuffix)\r\n      },\r\n      { ALT: () => $.SUBRULE($.arrayCreationExplicitInitSuffix) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "New",
        "label": "'new'",
        "idx": 0,
        "pattern": "new"
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "primitiveType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classOrInterfaceType",
                "idx": 0
              }
            ]
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 2,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "arrayCreationDefaultInitSuffix",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "arrayCreationExplicitInitSuffix",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "arrayCreationDefaultInitSuffix",
    "orgText": "() => {\r\n    $.SUBRULE($.dimExprs);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.dims);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "dimExprs",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dims",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "arrayCreationExplicitInitSuffix",
    "orgText": "() => {\r\n    $.SUBRULE($.dims);\r\n    $.SUBRULE($.arrayInitializer);\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "dims",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "arrayInitializer",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "dimExprs",
    "orgText": "() => {\r\n    $.SUBRULE($.dimExpr);\r\n    $.OPTION(() => {\r\n      $.SUBRULE2($.dimExpr);\r\n    });\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "dimExpr",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dimExpr",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "dimExpr",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.SUBRULE($.annotation);\r\n    });\r\n    $.CONSUME(t.LSquare);\r\n    $.SUBRULE($.expression);\r\n    $.CONSUME(t.RSquare);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "LSquare",
        "label": "'['",
        "idx": 0,
        "pattern": "["
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RSquare",
        "label": "']'",
        "idx": 0,
        "pattern": "]"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classLiteralSuffix",
    "orgText": "() => {\r\n    $.MANY(() => {\r\n      $.CONSUME(t.LSquare);\r\n      $.CONSUME(t.RSquare);\r\n    });\r\n    $.CONSUME(t.Dot);\r\n    $.CONSUME(t.Class);\r\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "LSquare",
            "label": "'['",
            "idx": 0,
            "pattern": "["
          },
          {
            "type": "Terminal",
            "name": "RSquare",
            "label": "']'",
            "idx": 0,
            "pattern": "]"
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Dot",
        "label": "'.'",
        "idx": 0,
        "pattern": "."
      },
      {
        "type": "Terminal",
        "name": "Class",
        "label": "'class'",
        "idx": 0,
        "pattern": "class"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "arrayAccessSuffix",
    "orgText": "() => {\r\n    $.CONSUME(t.LSquare);\r\n    $.SUBRULE($.expression);\r\n    $.CONSUME(t.RSquare);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LSquare",
        "label": "'['",
        "idx": 0,
        "pattern": "["
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RSquare",
        "label": "']'",
        "idx": 0,
        "pattern": "]"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodReferenceSuffix",
    "orgText": "() => {\r\n    $.CONSUME(t.ColonColon);\r\n    $.OPTION(() => {\r\n      $.SUBRULE($.typeArguments);\r\n    });\r\n\r\n    $.OR([\r\n      { ALT: () => $.CONSUME(t.Identifier) },\r\n      // TODO: a constructor method reference (\"new\") can only be used\r\n      //   in specific contexts, but perhaps this verification is best left\r\n      //   for a semantic analysis phase\r\n      { ALT: () => $.CONSUME(t.New) }\r\n    ]);\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "ColonColon",
        "label": "'::'",
        "idx": 0,
        "pattern": "::"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Identifier",
                "label": "Identifier",
                "idx": 0,
                "pattern": "[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "New",
                "label": "'new'",
                "idx": 0,
                "pattern": "new"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "identifyNewExpressionType",
    "orgText": "() => {\r\n    $.CONSUME(t.New);\r\n    const firstTokenAfterNew = this.LA(1).tokenType;\r\n\r\n    // not an array initialization due to the prefix \"TypeArguments\"\r\n    if (firstTokenAfterNew === t.Less) {\r\n      return newExpressionTypes.unqualifiedClassInstanceCreationExpression;\r\n    }\r\n\r\n    try {\r\n      $.SUBRULE($.classOrInterfaceTypeToInstantiate);\r\n    } catch (e) {\r\n      // if it is not a \"classOrInterfaceTypeToInstantiate\" then\r\n      // (assuming a valid input) we are looking at an \"arrayCreationExpression\"\r\n      return newExpressionTypes.arrayCreationExpression;\r\n    }\r\n\r\n    const firstTokenAfterClassType = this.LA(1).tokenType;\r\n    if (firstTokenAfterClassType === t.LBrace) {\r\n      return newExpressionTypes.unqualifiedClassInstanceCreationExpression;\r\n    }\r\n\r\n    // The LBrace above is mandatory in \"classInstanceCreation...\" so\r\n    // it must be an \"arrayCreationExp\" (if the input is valid)\r\n    // TODO: upgrade the logic to return \"unknown\" type if at this\r\n    //       point it does not match \"arrayCreation\" either.\r\n    //   - This will provide a better error message to the user\r\n    //     in case of invalid inputs\r\n    return newExpressionTypes.arrayCreationExpression;\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "New",
        "label": "'new'",
        "idx": 0,
        "pattern": "new"
      },
      {
        "type": "NonTerminal",
        "name": "classOrInterfaceTypeToInstantiate",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isLambdaExpression",
    "orgText": "() => {\r\n    // TODO: this check of next two tokens is probably redundant as the normal lookahead should take care of this.\r\n    const firstTokenType = this.LA(1).tokenType;\r\n    const secondTokenType = this.LA(2).tokenType;\r\n    // no parent lambda \"x -> x * 2\"\r\n    if (firstTokenType === t.Identifier && secondTokenType === t.Arrow) {\r\n      return true;\r\n    }\r\n    // Performance optimizations, fail fast if it is not a LBrace.\r\n    else if (firstTokenType === t.LBrace) {\r\n      $.SUBRULE($.lambdaParametersWithBraces);\r\n      const followedByArrow = this.LA(1).tokenType === t.Arrow;\r\n      return followedByArrow;\r\n    }\r\n    return false;\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "lambdaParametersWithBraces",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isCastExpression",
    "orgText": "() => {\r\n    if (this.BACKTRACK_LOOKAHEAD($.isPrimitiveCastExpression)) {\r\n      return true;\r\n    }\r\n    return this.BACKTRACK_LOOKAHEAD($.isReferenceTypeCastExpression);\r\n  }",
    "definition": []
  },
  {
    "type": "Rule",
    "name": "isPrimitiveCastExpression",
    "orgText": "() => {\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.primitiveType);\r\n    // No dims so this is not a reference Type\r\n    $.CONSUME(t.RBrace);\r\n    return true;\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "primitiveType",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isReferenceTypeCastExpression",
    "orgText": "() => {\r\n    if (firstForUnaryExpressionNotPlusMinus === undefined) {\r\n      const firstUnaryExpressionNotPlusMinus = this.computeContentAssist(\r\n        \"unaryExpressionNotPlusMinus\",\r\n        []\r\n      );\r\n      const nextTokTypes = firstUnaryExpressionNotPlusMinus.map(\r\n        x => x.nextTokenType\r\n      );\r\n      // uniq\r\n      firstForUnaryExpressionNotPlusMinus = nextTokTypes.filter(\r\n        (v, i, a) => a.indexOf(v) === i\r\n      );\r\n    }\r\n    $.CONSUME(t.LBrace);\r\n    $.SUBRULE($.referenceType);\r\n    $.MANY(() => {\r\n      $.SUBRULE($.additionalBound);\r\n    });\r\n    $.CONSUME(t.RBrace);\r\n    const firstTokTypeAfterRBrace = this.LA(1).tokenType;\r\n\r\n    return (\r\n      firstForUnaryExpressionNotPlusMinus.find(\r\n        tokType => tokType === firstTokTypeAfterRBrace\r\n      ) !== undefined\r\n    );\r\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "referenceType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "additionalBound",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isRefTypeInMethodRef",
    "orgText": "() => {\r\n    $.SUBRULE($.typeArguments);\r\n\r\n    // arrayType\r\n    const hasDims = $.OPTION(() => {\r\n      $.SUBRULE($.dims);\r\n    });\r\n\r\n    const firstTokTypeAfterTypeArgs = this.LA(1).tokenType;\r\n    if (firstTokTypeAfterTypeArgs === t.ColonColon) {\r\n      return true;\r\n    }\r\n    // we must be at the end of a \"referenceType\" if \"dims\" were encountered\r\n    // So there is not point to check farther\r\n    else if (hasDims) {\r\n      return false;\r\n    }\r\n\r\n    // in the middle of a \"classReferenceType\"\r\n    $.OPTION2(() => {\r\n      $.CONSUME(t.Dot);\r\n      $.SUBRULE($.classOrInterfaceType);\r\n    });\r\n\r\n    const firstTokTypeAfterRefType = this.LA(1).tokenType;\r\n    return firstTokTypeAfterRefType === t.ColonColon;\r\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "typeArguments",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dims",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "NonTerminal",
            "name": "classOrInterfaceType",
            "idx": 0
          }
        ]
      }
    ]
  }
];
</script>

<script>
    var diagramsDiv = document.getElementById("diagrams");
    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);
</script>
